<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>shim.woo API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#shim.woo.DEFAULT_DESCRIPTION">DEFAULT_DESCRIPTION</a></li>
  </ul>

    </li>


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#shim.woo.WooCommerceShim">WooCommerceShim</a></span>
        
          
  <ul>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.__init__">__init__</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.create_product">create_product</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_ebay_get_got_item_ids">db_ebay_get_got_item_ids</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_ebay_get_request_counter">db_ebay_get_request_counter</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_ebay_got_seller_list_date">db_ebay_got_seller_list_date</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_ebay_increment_request_counter">db_ebay_increment_request_counter</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_ebay_store_got_item_ids">db_ebay_store_got_item_ids</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_ebay_zero_request_counter">db_ebay_zero_request_counter</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_get_active_item_ids">db_get_active_item_ids</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_get_all_item_metadata">db_get_all_item_metadata</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_get_all_items">db_get_all_items</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_get_all_product_metadata">db_get_all_product_metadata</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_get_inactive_uploaded_item_ids">db_get_inactive_uploaded_item_ids</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_get_metadata_post_id_from_value">db_get_metadata_post_id_from_value</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_get_product_data">db_get_product_data</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_get_product_image_urls">db_get_product_image_urls</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_metadata_uploaded">db_metadata_uploaded</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_product_uploaded">db_product_uploaded</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_store_item_from_ebay">db_store_item_from_ebay</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_store_item_metadata_from_ebay">db_store_item_metadata_from_ebay</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.db_woo_get_post_id">db_woo_get_post_id</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.delete_all_products_in_range">delete_all_products_in_range</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.delete_product">delete_product</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.delete_product_images">delete_product_images</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.does_product_exist">does_product_exist</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.download_product_images_from_ebay">download_product_images_from_ebay</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.get_mapped_category_id">get_mapped_category_id</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.try_command">try_command</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.upload_image_to_woocommerce">upload_image_to_woocommerce</a></li>
    <li class="mono"><a href="#shim.woo.WooCommerceShim.upload_product_images">upload_product_images</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">shim.woo</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo" class="source">
    <pre><code>#!/usr/bin/env python3
# Part of Ebay-WooCommerce-Shim
# Copyright 2020 David Todd <dtodd@oceantech.com>
# License: Properitary

import os
import sys
import json
import time
import logging
import requests

from socket import timeout
from urllib3.exceptions import ReadTimeoutError

from .db import Database
from .util import LOG_HANDLER
from .image import Image

from woocommerce import API as WCAPI
from wordpress import API as WPAPI

DEFAULT_DESCRIPTION = """
<strong style="align-text:center;font-size:21px;">Request the price</strong>
[wpforms id="5280"]
"""

class WooCommerceShim(Database):
    """
        Contains various methods for interacting with
        the WooCommerce API. These methods will do things
        such as adding new products, and removing sold
        products.
    """

    def __init__(self, *args, **kwargs):
        super(WooCommerceShim, self).__init__(*args, **kwargs)

        # Setup logging
        self.log = logging.getLogger(__name__)
        self.log.setLevel(os.environ.get('log_level', 'INFO'))
        self.log.addHandler(LOG_HANDLER)

        self.api = WCAPI(
            url=os.environ.get('woo_url', False),
            consumer_key=os.environ.get('woo_key', False),
            consumer_secret=os.environ.get('woo_secret', False)
        )

        self.wp_api = WPAPI(
            url=os.environ.get('woo_url', False),
            api='wp-json',
            version='wp/v2',
            wp_user=os.environ.get('wordpress_user', False),
            wp_pass=os.environ.get('wordpress_app_password', False),
            basic_auth=True,
            user_auth=True,
            consumer_key=False,
            consumer_secret=False
        )

        mapping_path = os.environ.get('category_mapping',
                                      'database/ebay-to-woo-commerce-category-map.json')
        try:
            with open(mapping_path, 'r') as mapping_file:
                self.category_mapping = json.load(mapping_file)
        except IOError:
            self.category_mapping = None

    def __does_image_exist_on_woocommerce(self, slug):
        """
            Searches the Wordpress media library for
            any files that have a URL `slug` that
            matches the one provided

            Returns True if the file exists, and False otherwise

            This method is unreliable! Duplicates are basically guarenteed to happen...
        """

        self.log.info('Checking if a file has a slug matching: %s' % (slug))
        result = self.wp_api.get('/media?slug=%s' % (slug)).json()

        if len(result) == 0:
            return False
        return True

    def __divide_into_chunks(self, iterable, chunk_size=100):
        """
            Used to make bulk requests via the API, which limits
            the amount of products to change at once to 100

            `iterable` is something that can be iterated over, be
            it a list or a range. When a range, you must wrap the
            output of this method in `list()`

            `chunk_size` is optional, and defines how many products
            to change per request. The default of 100 is the maximum
            that the API will allow

            Returns the `iterable` containing as many items as are
            in the `chunk_size`
        """
        for i in range(0, len(iterable), chunk_size):
            yield iterable[i:i + chunk_size]

    def __search_map(self, value, field):
        """
            Uses List Comprehension to search for the `value` in the `field`.

            Normal usage would be similar to `self.__search_map(ebay_category_id, 'ebay_ids')`

            Returns an integer, which is the first matching Woo Commerce ID for
            the selected `value` (in the case that one ebay category is mapped to
            multiple woo commerce categories)

            When a matching category can't be found, this method will call itself
            to search for the "Uncategorized" `value` on the "wc-name" `field`
        """
        try:
            mapped = [key for key in self.category_mapping if value in key[field]]
            return int(mapped[0]['wc-id'])
        except IndexError: # Couldn't find it, return the uncategorized id
            return self.__search_map('Uncategorized', 'wc-name')

    def does_product_exist(self, item_id):
        """
            Determines if the product with the `item_id` has
            already been uploaded to WooCommerce, by checking
            for the truthyness of `post_id`
        """
        data = self.db_get_product_data(item_id)
        if data.get('post_id') is not None:
            return True
        return False

    def get_mapped_category_id(self, ebay_category_id):
        """
            Determines if the user provided a category mapping, and if so
            returns an integer, which is the Woo Commerce category id that
            is mapped to the `ebay_category_id` (or the Uncategorized category
            id if a mapping can not be found)

            In the case that the user has not provided a category mapping,
            this method returns None
        """
        if self.category_mapping is not None:
            return self.__search_map(ebay_category_id, 'ebay_ids')
        return None

    def download_product_images_from_ebay(self, item_id):
        """
            Downloads all of the images for a provided `item_id` and
            returns a dictionary containing the image name, mime type, and
            bytes-like object for the raw images

            The image URLs come from the database table `item_metadata`,
            which is populated when `self.__get_item_metadata()` runs
        """

        count = 0
        return_images = list()

        image_urls = self.db_get_product_image_urls(item_id)
        image_urls_count = len(image_urls)

        if image_urls_count > 0:
            self.log.info("Found %d image URLs for: %s" % (image_urls_count, item_id))

            for image in image_urls:
                url = image.get('value', '')

                if image.get('post_id') is not None:
                    self.log.warning("We've already uploaded %s, skipping download" % (url))
                    continue

                self.log.info("Downloading %s" % (url))
                req = requests.get(url)

                if req.content:
                    mime_type = req.headers.get('Content-Type', '')
                    slug = '%s-%d' % (item_id, count)
                    extension = mime_type.split('/')[1]
                    filename = '%s.%s' % (slug, extension)

                    if 'image' not in mime_type:
                        msg = "%d didn't get an image somehow. Content type was: %s"
                        self.log.error(msg % (item_id, mime_type))
                        continue

                    return_images.append(Image(
                        slug = slug,
                        ebay_url = url,
                        name = filename,
                        mime_type = mime_type,
                        data = req.content
                    ))

                    # self.log.info("Image %s downloaded" % (filename))

                    if count < image_urls_count:
                        self.log.debug("Waiting a quarter second until next download")
                        time.sleep(0.25)
                else:
                    self.log.error(
                        "No content returned. Is %s reachable in a browser?" % (url)
                    )

                count += 1
        else:
            self.log.warning("No Image URLs found for item: %s" % (item_id))

        return return_images

    def upload_image_to_woocommerce(self, image, post_id):
        """
            Uploads the provided `image` to wordpress, and returns the response

            `image` is a dictionary containing the following keys:

            `name` - This is the destination file name, including extension

            `type` - This is the MIMETYPE of the image, usually derived from the extension

            `data` - This is a bytes-like object representing the entire image. We get this
            from dowloading an image directly from Ebay's servers and temporarily storing it
            in memory

            `post_id` is the post in which to attach the image to. This is returned in the
            response from `self.create_product()`

            Returns either a string containing the URL the image can be found at, or False
            if the image fails to be uploaded
        """

        self.log.info("Uploading %s to wordpress" % (image.name))

        endpoint = '/media?post=%d' % (post_id)

        headers = {
            'cache-control': 'no-cache',
            'content-disposition': 'attachment; filename=%s' % (image.name),
            'content-type': '%s' % (image.mime_type)
        }

        # Don't upload a duplicate image if it was uploaded in the past
        if self.__does_image_exist_on_woocommerce(image.slug):
            self.log.warning(
                "Image %s already exists on wordpress. Not uploading again" % (image.name)
            )
            return None, None

        # Upload the image
        response = self.wp_api.post(endpoint, image.data, headers=headers)

        try:
            image_id = response.json().get('id')
            url = response.json().get('guid', dict).get('raw')
            self.log.debug("Uploaded %s to %s" % (image.name, url))
            return image_id, url
        except AttributeError:
            self.log.error('Could not upload %s' % image.name)
            return None, None

    def upload_product_images(self, item_id):
        """
            With the provided `item_id`, the database
            is searched for the post id (set during
            `create_product`)

            When the post_id is found, it will be used
            to download the images for that product
            from ebay, and then upload the images
        """
        post_id = self.db_woo_get_post_id(item_id)
        gallery = []

        if post_id is not None:
            for image in self.download_product_images_from_ebay(item_id):
                image_id, url = self.upload_image_to_woocommerce(image, post_id)
                if image_id and url:
                    self.db_metadata_uploaded(image_id, item_id)
                    gallery.append({'id': image_id})

            # Add the images to the gallery
            self.api.put('products/%d' % (post_id), {'images': gallery}).json()
        else:
            self.log.warning('The product %d has not yet been uploaded' % (item_id))

        return self

    def create_product(self, item_id):
        """
            Pulls the product related to the `item_id`
            out of the database and uploads it to WooCommerce

            Returns the result as JSON
        """
        attributes = list()
        attributes_to_upload = list()
        self.log.info('Creating a WooCommerce product from ebay id: %s' % (item_id))

        if self.does_product_exist(item_id):
            self.log.warning('Product with item id %d already exists, skipping' % (item_id))
            return self

        product = self.db_get_product_data(item_id)
        attributes = self.db_get_all_product_metadata(item_id)

        # Strip out any pictures
        attributes = [
            attribute for attribute in attributes
            if attribute['key'] != 'picture_url'
        ]

        # Format the attributes in a way that WooCommerce is expecting
        for index, attribute in enumerate(attributes):
            attributes_to_upload.append({
                'name': attribute['key'],
                'options': [ attribute['value'] ],
                'visible': True,
                'variation': True,
                'position': index,
            })

        upload_data = {
            'name': product['title'],
            'type': 'simple',
            'status': 'publish',
            'short_description': product['condition_description'],
            'description': DEFAULT_DESCRIPTION,
            'sku': product['sku'],
            # 'attributes': attributes_to_upload,
            # 'default_attributes': attributes_to_upload,
        }

        # Add the category id
        category_id = self.get_mapped_category_id(product.get('category_id', 0))
        if category_id is not None:
            upload_data['categories'] = [{ 'id': category_id }]

        res = self.api.post('products', upload_data).json()

        self.log.debug(res)

        if res.get('id', False):
            self.db_product_uploaded(res['id'], item_id)
        else:
            # Invalid or duplicate sku
            if res.get('code') == 'product_invalid_sku':
                if res.get('data') and res['data'].get('resource_id'):
                    new_post_id = res['data']['resource_id']
                    self.log.warning(
                        'The SKU for %s already exists for %s. Updating.' % (new_post_id, item_id))
                    self.db_product_uploaded(new_post_id, item_id)
            else:
                self.log.error('Unable to retrive product_id')
                self.log.debug(res)
                self.log.debug(upload_data)

        return self

    def delete_product_images(self, item_id):
        """
            With the provided `item_id`, an API request will
            be made to WooCommerce to identify all images
            associted with it. Then, it will delete each of
            those images.
        """

        # This feature has not been implemented.
        # Delete media through wordpress directly

        pass

    def delete_product(self, item_id):
        """
            With the provided `item_id`, an API request will
            be made to WooCommerce to force delete the item

            The `item_id` is supplied by the queue, which gets
            them from `db.db_get_inactive_uploaded_item_ids()`

            When an item is force deleted, it will not appear
            in the "Trash"

            Returns the response as a dictionary or None if
            there is no post id
        """
        post_id = self.db_woo_get_post_id(item_id)
        if post_id is not None:
            self.log.info('Deleting %d from WooCommerce' % (item_id))
            try:
                response = self.api.delete('products/%d' % (post_id), params={'force': True}).json()
            except TypeError:
                self.log.error("Got unexpected response type: %s" % (str(response)))
                return None

            self.delete_product_images(post_id)
            status_code = response.get('data', dict).get('staus', 500)

            if status_code == 404:
                self.log.warning("Product was already deleted")

            elif status_code < 300 and status_code > 199:
                self.log.info('Product deleted')

            else:
                self.log.debug(response)

            return response
        return None

    def delete_all_products_in_range(self, id_range, chunk_size=100):
        """
            With a provided `id_range`, which is expected to be
            a `range` or `list` type, multiple bulk requests
            will be made to the Woo Commerce API to delete
            those items.

            When `id_range` is of type(range), your ending ID needs
            to be the last ID to delete + 1

            Returns None
        """
        self.log.info('Deleting products from %d to %d' % (id_range[0], id_range[-1]))

        # The API says that it supports chunks up to 100 items, but in testing
        # it would always time out, even if it successfully deleted the items
        # with any chunk size greater than or equal to 50
        for chunk in self.__divide_into_chunks(id_range, chunk_size):
            post_ids = list(chunk)
            data = {
                'delete': post_ids
            }
            self.api.post('products/batch', data)
            self.log.info('Deleted ids %s' % (post_ids))

            for post_id in post_ids:
                self.delete_product_images(post_id)

    def try_command(self, command, data):
        """
            Wrapper for running methods.

            Verifies that we support the method, raising a NameError if not
            and then runs the method specified in the `command` argument in
            a try, except statement

            `command` is a string that is inside `__available_commands`

            `data` is dependent on the type of command that is being ran.
            In most instances, it is an integer containing the ebay ItemID.

            With the `delete_all_products` command, it is either a range or
            a list containing the post ids for existing products
        """
        __available_commands = [
            'create_product',
            'delete_product',
            'upload_images',
            'delete_all_products',
        ]

        err_msg = "Command %s is unrecognized. Supported commands are: %s" % (
            command, ', '.join(__available_commands))

        if command not in __available_commands:
            self.log.exception(err_msg)
            raise NameError(err_msg)

        try:
            if command == 'create_product':
                return self.create_product(data)

            elif command == 'delete_product':
                return self.delete_product(data)

            elif command == 'upload_images':
                return self.upload_product_images(data)

            elif command == 'delete_all_products':
                return self.delete_all_products_in_range(data)

            else:
                self.log.exception(err_msg)
                raise NameError(err_msg)

        # The several kinds of timeout exceptions that are normally returned by the API
        except (timeout, ReadTimeoutError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout):
            self.log.warning('The Previous request Timed Out. Waiting 5s before retrying')
            time.sleep(5)
            self.try_command(command, data)
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="shim.woo.DEFAULT_DESCRIPTION" class="name">var <span class="ident">DEFAULT_DESCRIPTION</span></p>
      
  
  <div class="source_cont">
</div>

      </div>


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="shim.woo.WooCommerceShim" class="name">class <span class="ident">WooCommerceShim</span></p>
      
  
    <div class="desc"><p>Contains various methods for interacting with
the WooCommerce API. These methods will do things
such as adding new products, and removing sold
products.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim" class="source">
    <pre><code>class WooCommerceShim(Database):
    """
        Contains various methods for interacting with
        the WooCommerce API. These methods will do things
        such as adding new products, and removing sold
        products.
    """

    def __init__(self, *args, **kwargs):
        super(WooCommerceShim, self).__init__(*args, **kwargs)

        # Setup logging
        self.log = logging.getLogger(__name__)
        self.log.setLevel(os.environ.get('log_level', 'INFO'))
        self.log.addHandler(LOG_HANDLER)

        self.api = WCAPI(
            url=os.environ.get('woo_url', False),
            consumer_key=os.environ.get('woo_key', False),
            consumer_secret=os.environ.get('woo_secret', False)
        )

        self.wp_api = WPAPI(
            url=os.environ.get('woo_url', False),
            api='wp-json',
            version='wp/v2',
            wp_user=os.environ.get('wordpress_user', False),
            wp_pass=os.environ.get('wordpress_app_password', False),
            basic_auth=True,
            user_auth=True,
            consumer_key=False,
            consumer_secret=False
        )

        mapping_path = os.environ.get('category_mapping',
                                      'database/ebay-to-woo-commerce-category-map.json')
        try:
            with open(mapping_path, 'r') as mapping_file:
                self.category_mapping = json.load(mapping_file)
        except IOError:
            self.category_mapping = None

    def __does_image_exist_on_woocommerce(self, slug):
        """
            Searches the Wordpress media library for
            any files that have a URL `slug` that
            matches the one provided

            Returns True if the file exists, and False otherwise

            This method is unreliable! Duplicates are basically guarenteed to happen...
        """

        self.log.info('Checking if a file has a slug matching: %s' % (slug))
        result = self.wp_api.get('/media?slug=%s' % (slug)).json()

        if len(result) == 0:
            return False
        return True

    def __divide_into_chunks(self, iterable, chunk_size=100):
        """
            Used to make bulk requests via the API, which limits
            the amount of products to change at once to 100

            `iterable` is something that can be iterated over, be
            it a list or a range. When a range, you must wrap the
            output of this method in `list()`

            `chunk_size` is optional, and defines how many products
            to change per request. The default of 100 is the maximum
            that the API will allow

            Returns the `iterable` containing as many items as are
            in the `chunk_size`
        """
        for i in range(0, len(iterable), chunk_size):
            yield iterable[i:i + chunk_size]

    def __search_map(self, value, field):
        """
            Uses List Comprehension to search for the `value` in the `field`.

            Normal usage would be similar to `self.__search_map(ebay_category_id, 'ebay_ids')`

            Returns an integer, which is the first matching Woo Commerce ID for
            the selected `value` (in the case that one ebay category is mapped to
            multiple woo commerce categories)

            When a matching category can't be found, this method will call itself
            to search for the "Uncategorized" `value` on the "wc-name" `field`
        """
        try:
            mapped = [key for key in self.category_mapping if value in key[field]]
            return int(mapped[0]['wc-id'])
        except IndexError: # Couldn't find it, return the uncategorized id
            return self.__search_map('Uncategorized', 'wc-name')

    def does_product_exist(self, item_id):
        """
            Determines if the product with the `item_id` has
            already been uploaded to WooCommerce, by checking
            for the truthyness of `post_id`
        """
        data = self.db_get_product_data(item_id)
        if data.get('post_id') is not None:
            return True
        return False

    def get_mapped_category_id(self, ebay_category_id):
        """
            Determines if the user provided a category mapping, and if so
            returns an integer, which is the Woo Commerce category id that
            is mapped to the `ebay_category_id` (or the Uncategorized category
            id if a mapping can not be found)

            In the case that the user has not provided a category mapping,
            this method returns None
        """
        if self.category_mapping is not None:
            return self.__search_map(ebay_category_id, 'ebay_ids')
        return None

    def download_product_images_from_ebay(self, item_id):
        """
            Downloads all of the images for a provided `item_id` and
            returns a dictionary containing the image name, mime type, and
            bytes-like object for the raw images

            The image URLs come from the database table `item_metadata`,
            which is populated when `self.__get_item_metadata()` runs
        """

        count = 0
        return_images = list()

        image_urls = self.db_get_product_image_urls(item_id)
        image_urls_count = len(image_urls)

        if image_urls_count > 0:
            self.log.info("Found %d image URLs for: %s" % (image_urls_count, item_id))

            for image in image_urls:
                url = image.get('value', '')

                if image.get('post_id') is not None:
                    self.log.warning("We've already uploaded %s, skipping download" % (url))
                    continue

                self.log.info("Downloading %s" % (url))
                req = requests.get(url)

                if req.content:
                    mime_type = req.headers.get('Content-Type', '')
                    slug = '%s-%d' % (item_id, count)
                    extension = mime_type.split('/')[1]
                    filename = '%s.%s' % (slug, extension)

                    if 'image' not in mime_type:
                        msg = "%d didn't get an image somehow. Content type was: %s"
                        self.log.error(msg % (item_id, mime_type))
                        continue

                    return_images.append(Image(
                        slug = slug,
                        ebay_url = url,
                        name = filename,
                        mime_type = mime_type,
                        data = req.content
                    ))

                    # self.log.info("Image %s downloaded" % (filename))

                    if count < image_urls_count:
                        self.log.debug("Waiting a quarter second until next download")
                        time.sleep(0.25)
                else:
                    self.log.error(
                        "No content returned. Is %s reachable in a browser?" % (url)
                    )

                count += 1
        else:
            self.log.warning("No Image URLs found for item: %s" % (item_id))

        return return_images

    def upload_image_to_woocommerce(self, image, post_id):
        """
            Uploads the provided `image` to wordpress, and returns the response

            `image` is a dictionary containing the following keys:

            `name` - This is the destination file name, including extension

            `type` - This is the MIMETYPE of the image, usually derived from the extension

            `data` - This is a bytes-like object representing the entire image. We get this
            from dowloading an image directly from Ebay's servers and temporarily storing it
            in memory

            `post_id` is the post in which to attach the image to. This is returned in the
            response from `self.create_product()`

            Returns either a string containing the URL the image can be found at, or False
            if the image fails to be uploaded
        """

        self.log.info("Uploading %s to wordpress" % (image.name))

        endpoint = '/media?post=%d' % (post_id)

        headers = {
            'cache-control': 'no-cache',
            'content-disposition': 'attachment; filename=%s' % (image.name),
            'content-type': '%s' % (image.mime_type)
        }

        # Don't upload a duplicate image if it was uploaded in the past
        if self.__does_image_exist_on_woocommerce(image.slug):
            self.log.warning(
                "Image %s already exists on wordpress. Not uploading again" % (image.name)
            )
            return None, None

        # Upload the image
        response = self.wp_api.post(endpoint, image.data, headers=headers)

        try:
            image_id = response.json().get('id')
            url = response.json().get('guid', dict).get('raw')
            self.log.debug("Uploaded %s to %s" % (image.name, url))
            return image_id, url
        except AttributeError:
            self.log.error('Could not upload %s' % image.name)
            return None, None

    def upload_product_images(self, item_id):
        """
            With the provided `item_id`, the database
            is searched for the post id (set during
            `create_product`)

            When the post_id is found, it will be used
            to download the images for that product
            from ebay, and then upload the images
        """
        post_id = self.db_woo_get_post_id(item_id)
        gallery = []

        if post_id is not None:
            for image in self.download_product_images_from_ebay(item_id):
                image_id, url = self.upload_image_to_woocommerce(image, post_id)
                if image_id and url:
                    self.db_metadata_uploaded(image_id, item_id)
                    gallery.append({'id': image_id})

            # Add the images to the gallery
            self.api.put('products/%d' % (post_id), {'images': gallery}).json()
        else:
            self.log.warning('The product %d has not yet been uploaded' % (item_id))

        return self

    def create_product(self, item_id):
        """
            Pulls the product related to the `item_id`
            out of the database and uploads it to WooCommerce

            Returns the result as JSON
        """
        attributes = list()
        attributes_to_upload = list()
        self.log.info('Creating a WooCommerce product from ebay id: %s' % (item_id))

        if self.does_product_exist(item_id):
            self.log.warning('Product with item id %d already exists, skipping' % (item_id))
            return self

        product = self.db_get_product_data(item_id)
        attributes = self.db_get_all_product_metadata(item_id)

        # Strip out any pictures
        attributes = [
            attribute for attribute in attributes
            if attribute['key'] != 'picture_url'
        ]

        # Format the attributes in a way that WooCommerce is expecting
        for index, attribute in enumerate(attributes):
            attributes_to_upload.append({
                'name': attribute['key'],
                'options': [ attribute['value'] ],
                'visible': True,
                'variation': True,
                'position': index,
            })

        upload_data = {
            'name': product['title'],
            'type': 'simple',
            'status': 'publish',
            'short_description': product['condition_description'],
            'description': DEFAULT_DESCRIPTION,
            'sku': product['sku'],
            # 'attributes': attributes_to_upload,
            # 'default_attributes': attributes_to_upload,
        }

        # Add the category id
        category_id = self.get_mapped_category_id(product.get('category_id', 0))
        if category_id is not None:
            upload_data['categories'] = [{ 'id': category_id }]

        res = self.api.post('products', upload_data).json()

        self.log.debug(res)

        if res.get('id', False):
            self.db_product_uploaded(res['id'], item_id)
        else:
            # Invalid or duplicate sku
            if res.get('code') == 'product_invalid_sku':
                if res.get('data') and res['data'].get('resource_id'):
                    new_post_id = res['data']['resource_id']
                    self.log.warning(
                        'The SKU for %s already exists for %s. Updating.' % (new_post_id, item_id))
                    self.db_product_uploaded(new_post_id, item_id)
            else:
                self.log.error('Unable to retrive product_id')
                self.log.debug(res)
                self.log.debug(upload_data)

        return self

    def delete_product_images(self, item_id):
        """
            With the provided `item_id`, an API request will
            be made to WooCommerce to identify all images
            associted with it. Then, it will delete each of
            those images.
        """

        # This feature has not been implemented.
        # Delete media through wordpress directly

        pass

    def delete_product(self, item_id):
        """
            With the provided `item_id`, an API request will
            be made to WooCommerce to force delete the item

            The `item_id` is supplied by the queue, which gets
            them from `db.db_get_inactive_uploaded_item_ids()`

            When an item is force deleted, it will not appear
            in the "Trash"

            Returns the response as a dictionary or None if
            there is no post id
        """
        post_id = self.db_woo_get_post_id(item_id)
        if post_id is not None:
            self.log.info('Deleting %d from WooCommerce' % (item_id))
            try:
                response = self.api.delete('products/%d' % (post_id), params={'force': True}).json()
            except TypeError:
                self.log.error("Got unexpected response type: %s" % (str(response)))
                return None

            self.delete_product_images(post_id)
            status_code = response.get('data', dict).get('staus', 500)

            if status_code == 404:
                self.log.warning("Product was already deleted")

            elif status_code < 300 and status_code > 199:
                self.log.info('Product deleted')

            else:
                self.log.debug(response)

            return response
        return None

    def delete_all_products_in_range(self, id_range, chunk_size=100):
        """
            With a provided `id_range`, which is expected to be
            a `range` or `list` type, multiple bulk requests
            will be made to the Woo Commerce API to delete
            those items.

            When `id_range` is of type(range), your ending ID needs
            to be the last ID to delete + 1

            Returns None
        """
        self.log.info('Deleting products from %d to %d' % (id_range[0], id_range[-1]))

        # The API says that it supports chunks up to 100 items, but in testing
        # it would always time out, even if it successfully deleted the items
        # with any chunk size greater than or equal to 50
        for chunk in self.__divide_into_chunks(id_range, chunk_size):
            post_ids = list(chunk)
            data = {
                'delete': post_ids
            }
            self.api.post('products/batch', data)
            self.log.info('Deleted ids %s' % (post_ids))

            for post_id in post_ids:
                self.delete_product_images(post_id)

    def try_command(self, command, data):
        """
            Wrapper for running methods.

            Verifies that we support the method, raising a NameError if not
            and then runs the method specified in the `command` argument in
            a try, except statement

            `command` is a string that is inside `__available_commands`

            `data` is dependent on the type of command that is being ran.
            In most instances, it is an integer containing the ebay ItemID.

            With the `delete_all_products` command, it is either a range or
            a list containing the post ids for existing products
        """
        __available_commands = [
            'create_product',
            'delete_product',
            'upload_images',
            'delete_all_products',
        ]

        err_msg = "Command %s is unrecognized. Supported commands are: %s" % (
            command, ', '.join(__available_commands))

        if command not in __available_commands:
            self.log.exception(err_msg)
            raise NameError(err_msg)

        try:
            if command == 'create_product':
                return self.create_product(data)

            elif command == 'delete_product':
                return self.delete_product(data)

            elif command == 'upload_images':
                return self.upload_product_images(data)

            elif command == 'delete_all_products':
                return self.delete_all_products_in_range(data)

            else:
                self.log.exception(err_msg)
                raise NameError(err_msg)

        # The several kinds of timeout exceptions that are normally returned by the API
        except (timeout, ReadTimeoutError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout):
            self.log.warning('The Previous request Timed Out. Waiting 5s before retrying')
            time.sleep(5)
            self.try_command(command, data)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#shim.woo.WooCommerceShim">WooCommerceShim</a></li>
          <li>shim.db.Database</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.__init__', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.__init__" class="source">
    <pre><code>def __init__(self, *args, **kwargs):
    super(WooCommerceShim, self).__init__(*args, **kwargs)
    # Setup logging
    self.log = logging.getLogger(__name__)
    self.log.setLevel(os.environ.get('log_level', 'INFO'))
    self.log.addHandler(LOG_HANDLER)
    self.api = WCAPI(
        url=os.environ.get('woo_url', False),
        consumer_key=os.environ.get('woo_key', False),
        consumer_secret=os.environ.get('woo_secret', False)
    )
    self.wp_api = WPAPI(
        url=os.environ.get('woo_url', False),
        api='wp-json',
        version='wp/v2',
        wp_user=os.environ.get('wordpress_user', False),
        wp_pass=os.environ.get('wordpress_app_password', False),
        basic_auth=True,
        user_auth=True,
        consumer_key=False,
        consumer_secret=False
    )
    mapping_path = os.environ.get('category_mapping',
                                  'database/ebay-to-woo-commerce-category-map.json')
    try:
        with open(mapping_path, 'r') as mapping_file:
            self.category_mapping = json.load(mapping_file)
    except IOError:
        self.category_mapping = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.create_product">
    <p>def <span class="ident">create_product</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Pulls the product related to the <code>item_id</code>
out of the database and uploads it to WooCommerce</p>
<p>Returns the result as JSON</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.create_product', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.create_product" class="source">
    <pre><code>def create_product(self, item_id):
    """
        Pulls the product related to the `item_id`
        out of the database and uploads it to WooCommerce
        Returns the result as JSON
    """
    attributes = list()
    attributes_to_upload = list()
    self.log.info('Creating a WooCommerce product from ebay id: %s' % (item_id))
    if self.does_product_exist(item_id):
        self.log.warning('Product with item id %d already exists, skipping' % (item_id))
        return self
    product = self.db_get_product_data(item_id)
    attributes = self.db_get_all_product_metadata(item_id)
    # Strip out any pictures
    attributes = [
        attribute for attribute in attributes
        if attribute['key'] != 'picture_url'
    ]
    # Format the attributes in a way that WooCommerce is expecting
    for index, attribute in enumerate(attributes):
        attributes_to_upload.append({
            'name': attribute['key'],
            'options': [ attribute['value'] ],
            'visible': True,
            'variation': True,
            'position': index,
        })
    upload_data = {
        'name': product['title'],
        'type': 'simple',
        'status': 'publish',
        'short_description': product['condition_description'],
        'description': DEFAULT_DESCRIPTION,
        'sku': product['sku'],
        # 'attributes': attributes_to_upload,
        # 'default_attributes': attributes_to_upload,
    }
    # Add the category id
    category_id = self.get_mapped_category_id(product.get('category_id', 0))
    if category_id is not None:
        upload_data['categories'] = [{ 'id': category_id }]
    res = self.api.post('products', upload_data).json()
    self.log.debug(res)
    if res.get('id', False):
        self.db_product_uploaded(res['id'], item_id)
    else:
        # Invalid or duplicate sku
        if res.get('code') == 'product_invalid_sku':
            if res.get('data') and res['data'].get('resource_id'):
                new_post_id = res['data']['resource_id']
                self.log.warning(
                    'The SKU for %s already exists for %s. Updating.' % (new_post_id, item_id))
                self.db_product_uploaded(new_post_id, item_id)
        else:
            self.log.error('Unable to retrive product_id')
            self.log.debug(res)
            self.log.debug(upload_data)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_ebay_get_got_item_ids">
    <p>def <span class="ident">db_ebay_get_got_item_ids</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Provides a starting point for the program to
continue from when it pulls the item metadata</p>
<p>In the case that no ids were stored previously,
this will default to all active items</p>
<p>Returns a list of ebay item ids</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_ebay_get_got_item_ids', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_ebay_get_got_item_ids" class="source">
    <pre><code>def db_ebay_get_got_item_ids(self):
    """
        Provides a starting point for the program to
        continue from when it pulls the item metadata
        In the case that no ids were stored previously,
        this will default to all active items
        Returns a list of ebay item ids
    """
    query = "SELECT value FROM ebay_internals WHERE key = 'got_item_ids'"
    self.__execute(query)
    ids = json.loads(self.__fetchone('value', '[]'))
    if not ids:
        self.log.warning('No continue point, getting all active items')
        return self.db_get_active_item_ids()
    return ids
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_ebay_get_request_counter">
    <p>def <span class="ident">db_ebay_get_request_counter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns an integer that is the total amount of requests today</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_ebay_get_request_counter', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_ebay_get_request_counter" class="source">
    <pre><code>def db_ebay_get_request_counter(self):
    """
        Returns an integer that is the total amount of requests today
    """
    query = "SELECT value FROM ebay_internals where key = 'requests_today'"
    self.__execute(query)
    return int(self.__fetchone('value', 0))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_ebay_got_seller_list_date">
    <p>def <span class="ident">db_ebay_got_seller_list_date</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Provides a method for preventing the <code>get_seller_list</code> command
from being ran multiple times a day</p>
<p>Returns True when there is either no date, or the date was in
the past. Returns False when there is a date that is today or
in the future</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_ebay_got_seller_list_date', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_ebay_got_seller_list_date" class="source">
    <pre><code>def db_ebay_got_seller_list_date(self):
    """
        Provides a method for preventing the `get_seller_list` command
        from being ran multiple times a day
        Returns True when there is either no date, or the date was in
        the past. Returns False when there is a date that is today or
        in the future
    """
    query = "SELECT value FROM ebay_internals WHERE key = 'got_seller_list_date'"
    self.__execute(query)
    last_date = self.__fetchone('value', 'no')
    if last_date != 'no' and isodate.parse_date(last_date) >= datetime.date.today():
        msg = 'We already ran get_seller_list today (or in the future). Wait until tomorrow'
        self.log.warning(msg)
        return False
    if last_date == 'no' or isodate.parse_date(last_date) < datetime.date.today():
        query = "UPDATE ebay_internals SET value = :isodate WHERE key = 'got_seller_list_date'"
        today = isodate.date_isoformat(datetime.date.today())
        self.__execute(query, {'isodate': today})
        self.db_ebay_zero_request_counter()
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_ebay_increment_request_counter">
    <p>def <span class="ident">db_ebay_increment_request_counter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>For every request made to the ebay API
(Currently only when getting metadata),
we add one to the request counter</p>
<p>Returns None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_ebay_increment_request_counter', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_ebay_increment_request_counter" class="source">
    <pre><code>def db_ebay_increment_request_counter(self):
    """
        For every request made to the ebay API
        (Currently only when getting metadata),
        we add one to the request counter
        Returns None
    """
    requests = self.db_ebay_get_request_counter()
    query = "UPDATE ebay_internals SET value = :requests WHERE key = 'requests_today'"
    self.__execute(query, {'requests': requests + 1,})
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_ebay_store_got_item_ids">
    <p>def <span class="ident">db_ebay_store_got_item_ids</span>(</p><p>self, item_ids)</p>
    </div>
    

    
  
    <div class="desc"><p>Used to save the current state of the program
whenever we hit a rate limit</p>
<p>Returns None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_ebay_store_got_item_ids', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_ebay_store_got_item_ids" class="source">
    <pre><code>def db_ebay_store_got_item_ids(self, item_ids):
    """
        Used to save the current state of the program
        whenever we hit a rate limit
        Returns None
    """
    query = "UPDATE ebay_internals SET value = :items WHERE key = 'got_item_ids'"
    self.__execute(query, {'items': json.dumps(item_ids),})
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_ebay_zero_request_counter">
    <p>def <span class="ident">db_ebay_zero_request_counter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Resets the request counter to 0</p>
<p>The request counter is used to ensure that
we don't make so many API requests to ebay
that we hit the rate limit (5000 requests/day)</p>
<p>Returns None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_ebay_zero_request_counter', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_ebay_zero_request_counter" class="source">
    <pre><code>def db_ebay_zero_request_counter(self):
    """
        Resets the request counter to 0
        The request counter is used to ensure that
        we don't make so many API requests to ebay
        that we hit the rate limit (5000 requests/day)
        Returns None
    """
    query = "UPDATE ebay_internals SET value = 0 WHERE key = 'requests_today'"
    self.__execute(query)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_get_active_item_ids">
    <p>def <span class="ident">db_get_active_item_ids</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Searches the local database for all items that
are marked as active</p>
<p>Returns a list containing all the item ids</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_get_active_item_ids', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_get_active_item_ids" class="source">
    <pre><code>def db_get_active_item_ids(self):
    """
        Searches the local database for all items that
        are marked as active
        Returns a list containing all the item ids
    """
    self.log.debug('Getting all active IDs')
    query = "SELECT item_id FROM items WHERE active = 'Active' AND post_id IS NULL;"
    self.__execute(query)
    item_ids = self.__cursor.fetchall()
    return [ i['item_id'] for i in item_ids if i['item_id'] ]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_get_all_item_metadata">
    <p>def <span class="ident">db_get_all_item_metadata</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_get_all_item_metadata', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_get_all_item_metadata" class="source">
    <pre><code>def db_get_all_item_metadata(self):
    self.__execute('SELECT * from item_metadata')
    return self.__fetchall()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_get_all_items">
    <p>def <span class="ident">db_get_all_items</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_get_all_items', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_get_all_items" class="source">
    <pre><code>def db_get_all_items(self):
    self.__execute('SELECT * FROM items;')
    return self.__fetchall()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_get_all_product_metadata">
    <p>def <span class="ident">db_get_all_product_metadata</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>For the provided <code>item_id</code>, the local database
is searched for all occurrences of metadata that
match, and extracts that if any are found</p>
<p>Returns a list of dictionaries, where each dictionary
is one key-value combination for the data stored
or an empty list if nothing is found</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_get_all_product_metadata', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_get_all_product_metadata" class="source">
    <pre><code>def db_get_all_product_metadata(self, item_id):
    """
        For the provided `item_id`, the local database
        is searched for all occurrences of metadata that
        match, and extracts that if any are found
        Returns a list of dictionaries, where each dictionary
        is one key-value combination for the data stored
        or an empty list if nothing is found
    """
    query = "SELECT key, value FROM item_metadata WHERE item_id = :item_id;"
    values = {
        'item_id': str(item_id),
    }
    self.__execute(query, values)
    return self.__fetchall()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_get_inactive_uploaded_item_ids">
    <p>def <span class="ident">db_get_inactive_uploaded_item_ids</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_get_inactive_uploaded_item_ids', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_get_inactive_uploaded_item_ids" class="source">
    <pre><code>def db_get_inactive_uploaded_item_ids(self):
    query = """
        SELECT item_id FROM items
        WHERE
            post_id is not NULL AND
            active != 'Active' OR
            end_date <= date('now')
    """
    self.__execute(query)
    item_ids = self.__fetchall()
    return [ i['item_id'] for i in item_ids if i['item_id'] ]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_get_metadata_post_id_from_value">
    <p>def <span class="ident">db_get_metadata_post_id_from_value</span>(</p><p>self, value)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_get_metadata_post_id_from_value', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_get_metadata_post_id_from_value" class="source">
    <pre><code>def db_get_metadata_post_id_from_value(self, value):
    query = """
        SELECT * FROM item_metadata
        WHERE value = :value
        LIMIT 1
    """
    self.__execute(query, {'value': value})
    return self.__fetchone('post_id')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_get_product_data">
    <p>def <span class="ident">db_get_product_data</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>For the provided <code>item_id</code>, the local database
is searched for the matching row and extracts it
if one is found, and it has quantity and is marked
as active</p>
<p>Returns a dictionary containing the product data
or an empty dictionary</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_get_product_data', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_get_product_data" class="source">
    <pre><code>def db_get_product_data(self, item_id):
    """
        For the provided `item_id`, the local database
        is searched for the matching row and extracts it
        if one is found, and it has quantity and is marked
        as active
        Returns a dictionary containing the product data
        or an empty dictionary
    """
    query = """
        SELECT *
        FROM items
        WHERE
            available_quantity > 0 AND
            item_id = :item_id
        LIMIT 1
    """
    values = {
        'item_id': str(item_id),
    }
    self.__execute(query, values)
    try:
        return dict(self.__cursor.fetchone())
    except TypeError:
        return {}
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_get_product_image_urls">
    <p>def <span class="ident">db_get_product_image_urls</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Gets all product image URLs that are
associated with a particular <code>item_id</code></p>
<p>Returns a list containing one or more
URLs to download images from, sorted
alphabetically</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_get_product_image_urls', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_get_product_image_urls" class="source">
    <pre><code>def db_get_product_image_urls(self, item_id):
    """
        Gets all product image URLs that are
        associated with a particular `item_id`
        Returns a list containing one or more
        URLs to download images from, sorted
        alphabetically
    """
    query = """
        SELECT value, post_id FROM item_metadata
        WHERE
            item_id = :item_id AND
            key = 'picture_url'
        ORDER BY value;
    """
    values = {
        'item_id': str(item_id),
    }
    self.__execute(query, values)
    return self.__fetchall()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_metadata_uploaded">
    <p>def <span class="ident">db_metadata_uploaded</span>(</p><p>self, post_id, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Shortcut to mark product metadata (such as images and attributes)
as uploaded by storing the post it is a part of</p>
<p>Returns <code>self</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_metadata_uploaded', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_metadata_uploaded" class="source">
    <pre><code>def db_metadata_uploaded(self, post_id, item_id):
    """
        Shortcut to mark product metadata (such as images and attributes)
        as uploaded by storing the post it is a part of
        Returns `self`
    """
    return self.__mark_data_as_uploaded('metadata', post_id, item_id)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_product_uploaded">
    <p>def <span class="ident">db_product_uploaded</span>(</p><p>self, post_id, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Shortcut to mark products as uploaded by storing the post it is a part of</p>
<p>Returns <code>self</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_product_uploaded', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_product_uploaded" class="source">
    <pre><code>def db_product_uploaded(self, post_id, item_id):
    """
        Shortcut to mark products as uploaded by storing the post it is a part of
        Returns `self`
    """
    return self.__mark_data_as_uploaded('product', post_id, item_id)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_store_item_from_ebay">
    <p>def <span class="ident">db_store_item_from_ebay</span>(</p><p>self, item)</p>
    </div>
    

    
  
    <div class="desc"><p>Store the provided <code>item</code>, which is a dictionary,
into the local database. This gets all information
that is normally returned from GetSellerList.</p>
<p>For ItemSpecifics, we will have to make a seperate
API call to GetItem with the DetailLevel set to
ReturnAll (something that is not allowed on bulk
queries such as GetSellerList and GetSellerEvents)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_store_item_from_ebay', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_store_item_from_ebay" class="source">
    <pre><code>def db_store_item_from_ebay(self, item):
    """
        Store the provided `item`, which is a dictionary,
        into the local database. This gets all information
        that is normally returned from GetSellerList.
        For ItemSpecifics, we will have to make a seperate
        API call to GetItem with the DetailLevel set to
        ReturnAll (something that is not allowed on bulk
        queries such as GetSellerList and GetSellerEvents)
    """
    # INSERT OR REPLACE so that we can always ensure that the
    # saved information is up to date (or at least recent)
    query = """
        INSERT OR REPLACE INTO items (
            item_id, active, available_quantity,
            title, sku, start_date, end_date,
            category_id, category_name, condition_name,
            condition_description
        ) VALUES (
            :item_id, :active, :available_quantity,
            :title, :sku, :start_date, :end_date,
            :category_id, :category_name, :condition_name,
            :condition_description)
    """
    values = {
        'item_id': int(item['ItemID']),
        'active': item['SellingStatus']['ListingStatus'],
        'available_quantity': int(item['Quantity']) - int(item['SellingStatus']['QuantitySold']),
        'title': item['Title'],
        'sku': item.get('SKU', uuid.uuid4().hex),
        'start_date': self.__get_datetime_obj(item['ListingDetails']['StartTime']),
        'end_date': self.__get_datetime_obj(item['ListingDetails']['EndTime']),
        'category_id': int(item['PrimaryCategory']['CategoryID']),
        'category_name': item['PrimaryCategory']['CategoryName'],
        'condition_name': '',
        'condition_description': '',
    }
    # These fields have a chance to not exist, so we set default empty values
    # and then try to add them after the dictionary is created
    if item.get('ConditionDisplayName', False):
        values['condition_name'] = item['ConditionDisplayName']
    if item.get('ConditionDescription', False):
        values['condition_description'] = item['ConditionDescription']
    self.__execute(query, values)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_store_item_metadata_from_ebay">
    <p>def <span class="ident">db_store_item_metadata_from_ebay</span>(</p><p>self, item)</p>
    </div>
    

    
  
    <div class="desc"><p>Store the provided <code>item</code>, which is a dictionary,
into the local database. We're specifically after
metadata such as picture urls, and item specifics.</p>
<p>When this is called from GetSellerList, the PictureDetails
are what are normally provided. When this is called from
GetItem, ItemSpecifics are what are normally provided</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_store_item_metadata_from_ebay', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_store_item_metadata_from_ebay" class="source">
    <pre><code>def db_store_item_metadata_from_ebay(self, item):
    """
        Store the provided `item`, which is a dictionary,
        into the local database. We're specifically after
        metadata such as picture urls, and item specifics.
        When this is called from GetSellerList, the PictureDetails
        are what are normally provided. When this is called from
        GetItem, ItemSpecifics are what are normally provided
    """
    # PictureDetails exists on GetSellerList and GetItem, so this should always get hit
    if item.get('PictureDetails', False):
        self.log.debug('Found Picture Details for %d' % (int(item['ItemID'])))
        if type(item['PictureDetails']['PictureURL']) is list:
            for picture in item['PictureDetails']['PictureURL']:
                self.__store_key_value(item['ItemID'], 'picture_url', picture)
        # Case for only one picture being on a listing
        elif type(item['PictureDetails']['PictureURL']) is str:
            self.__store_key_value(
                item['ItemID'], 'picture_url',
                item['PictureDetails']['PictureURL'])
        else:
            err_msg = 'Unexpected type %s from PictureDetails. Expecting either list or str'
            self.log.error(err_msg % (type(item['PictureDetails']['PictureURL'])))
    # ItemSpecifics only exists on GetItem when `IncludeItemSpecifics` is True
    if item.get('ItemSpecifics', False):
        self.log.debug('Found Specific Details for %d' % (int(item['ItemID'])))
        if type(item['ItemSpecifics']['NameValueList']) is list:
            for detail in item['ItemSpecifics']['NameValueList']:
                if type(detail['Value']) is list:
                    detail['Value'] = ', '.join(detail['Value'])
                self.__store_key_value(item['ItemID'], detail['Name'], detail['Value'])
        # Case for only one ItemSpecifc field
        elif type(item['ItemSpecifics']['NameValueList']) is dict:
            values = item['ItemSpecifics']['NameValueList']
            if type(values['Value']) is list:
                detail['Value'] = ', '.join(detail['Value'])
            self.__store_key_value(item['ItemID'], values['Name'], values['Value'])
        else:
            err_msg = 'Unexpected type %s from ItemSpecifics. Expecting either list or str'
            self.log.error(err_msg % (type(item['ItemSpecifics']['NameValueList'])))
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.db_woo_get_post_id">
    <p>def <span class="ident">db_woo_get_post_id</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Searches the database for <code>item_id</code>, and will
return the value of the <code>post_id</code> column.</p>
<p>If the product has not been uploaded to Woo Commerce,
this will return None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.db_woo_get_post_id', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.db_woo_get_post_id" class="source">
    <pre><code>def db_woo_get_post_id(self, item_id):
    """
        Searches the database for `item_id`, and will
        return the value of the `post_id` column.
        If the product has not been uploaded to Woo Commerce,
        this will return None
    """
    query = "SELECT post_id FROM items WHERE item_id = :item_id"
    self.__execute(query, {'item_id': item_id})
    return self.__fetchone('post_id')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.delete_all_products_in_range">
    <p>def <span class="ident">delete_all_products_in_range</span>(</p><p>self, id_range, chunk_size=100)</p>
    </div>
    

    
  
    <div class="desc"><p>With a provided <code>id_range</code>, which is expected to be
a <code>range</code> or <code>list</code> type, multiple bulk requests
will be made to the Woo Commerce API to delete
those items.</p>
<p>When <code>id_range</code> is of type(range), your ending ID needs
to be the last ID to delete + 1</p>
<p>Returns None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.delete_all_products_in_range', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.delete_all_products_in_range" class="source">
    <pre><code>def delete_all_products_in_range(self, id_range, chunk_size=100):
    """
        With a provided `id_range`, which is expected to be
        a `range` or `list` type, multiple bulk requests
        will be made to the Woo Commerce API to delete
        those items.
        When `id_range` is of type(range), your ending ID needs
        to be the last ID to delete + 1
        Returns None
    """
    self.log.info('Deleting products from %d to %d' % (id_range[0], id_range[-1]))
    # The API says that it supports chunks up to 100 items, but in testing
    # it would always time out, even if it successfully deleted the items
    # with any chunk size greater than or equal to 50
    for chunk in self.__divide_into_chunks(id_range, chunk_size):
        post_ids = list(chunk)
        data = {
            'delete': post_ids
        }
        self.api.post('products/batch', data)
        self.log.info('Deleted ids %s' % (post_ids))
        for post_id in post_ids:
            self.delete_product_images(post_id)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.delete_product">
    <p>def <span class="ident">delete_product</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>With the provided <code>item_id</code>, an API request will
be made to WooCommerce to force delete the item</p>
<p>The <code>item_id</code> is supplied by the queue, which gets
them from <code>db.db_get_inactive_uploaded_item_ids()</code></p>
<p>When an item is force deleted, it will not appear
in the "Trash"</p>
<p>Returns the response as a dictionary or None if
there is no post id</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.delete_product', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.delete_product" class="source">
    <pre><code>def delete_product(self, item_id):
    """
        With the provided `item_id`, an API request will
        be made to WooCommerce to force delete the item
        The `item_id` is supplied by the queue, which gets
        them from `db.db_get_inactive_uploaded_item_ids()`
        When an item is force deleted, it will not appear
        in the "Trash"
        Returns the response as a dictionary or None if
        there is no post id
    """
    post_id = self.db_woo_get_post_id(item_id)
    if post_id is not None:
        self.log.info('Deleting %d from WooCommerce' % (item_id))
        try:
            response = self.api.delete('products/%d' % (post_id), params={'force': True}).json()
        except TypeError:
            self.log.error("Got unexpected response type: %s" % (str(response)))
            return None
        self.delete_product_images(post_id)
        status_code = response.get('data', dict).get('staus', 500)
        if status_code == 404:
            self.log.warning("Product was already deleted")
        elif status_code < 300 and status_code > 199:
            self.log.info('Product deleted')
        else:
            self.log.debug(response)
        return response
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.delete_product_images">
    <p>def <span class="ident">delete_product_images</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>With the provided <code>item_id</code>, an API request will
be made to WooCommerce to identify all images
associted with it. Then, it will delete each of
those images.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.delete_product_images', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.delete_product_images" class="source">
    <pre><code>def delete_product_images(self, item_id):
    """
        With the provided `item_id`, an API request will
        be made to WooCommerce to identify all images
        associted with it. Then, it will delete each of
        those images.
    """
    # This feature has not been implemented.
    # Delete media through wordpress directly
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.does_product_exist">
    <p>def <span class="ident">does_product_exist</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Determines if the product with the <code>item_id</code> has
already been uploaded to WooCommerce, by checking
for the truthyness of <code>post_id</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.does_product_exist', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.does_product_exist" class="source">
    <pre><code>def does_product_exist(self, item_id):
    """
        Determines if the product with the `item_id` has
        already been uploaded to WooCommerce, by checking
        for the truthyness of `post_id`
    """
    data = self.db_get_product_data(item_id)
    if data.get('post_id') is not None:
        return True
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.download_product_images_from_ebay">
    <p>def <span class="ident">download_product_images_from_ebay</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Downloads all of the images for a provided <code>item_id</code> and
returns a dictionary containing the image name, mime type, and
bytes-like object for the raw images</p>
<p>The image URLs come from the database table <code>item_metadata</code>,
which is populated when <code>self.__get_item_metadata()</code> runs</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.download_product_images_from_ebay', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.download_product_images_from_ebay" class="source">
    <pre><code>def download_product_images_from_ebay(self, item_id):
    """
        Downloads all of the images for a provided `item_id` and
        returns a dictionary containing the image name, mime type, and
        bytes-like object for the raw images
        The image URLs come from the database table `item_metadata`,
        which is populated when `self.__get_item_metadata()` runs
    """
    count = 0
    return_images = list()
    image_urls = self.db_get_product_image_urls(item_id)
    image_urls_count = len(image_urls)
    if image_urls_count > 0:
        self.log.info("Found %d image URLs for: %s" % (image_urls_count, item_id))
        for image in image_urls:
            url = image.get('value', '')
            if image.get('post_id') is not None:
                self.log.warning("We've already uploaded %s, skipping download" % (url))
                continue
            self.log.info("Downloading %s" % (url))
            req = requests.get(url)
            if req.content:
                mime_type = req.headers.get('Content-Type', '')
                slug = '%s-%d' % (item_id, count)
                extension = mime_type.split('/')[1]
                filename = '%s.%s' % (slug, extension)
                if 'image' not in mime_type:
                    msg = "%d didn't get an image somehow. Content type was: %s"
                    self.log.error(msg % (item_id, mime_type))
                    continue
                return_images.append(Image(
                    slug = slug,
                    ebay_url = url,
                    name = filename,
                    mime_type = mime_type,
                    data = req.content
                ))
                # self.log.info("Image %s downloaded" % (filename))
                if count < image_urls_count:
                    self.log.debug("Waiting a quarter second until next download")
                    time.sleep(0.25)
            else:
                self.log.error(
                    "No content returned. Is %s reachable in a browser?" % (url)
                )
            count += 1
    else:
        self.log.warning("No Image URLs found for item: %s" % (item_id))
    return return_images
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.get_mapped_category_id">
    <p>def <span class="ident">get_mapped_category_id</span>(</p><p>self, ebay_category_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Determines if the user provided a category mapping, and if so
returns an integer, which is the Woo Commerce category id that
is mapped to the <code>ebay_category_id</code> (or the Uncategorized category
id if a mapping can not be found)</p>
<p>In the case that the user has not provided a category mapping,
this method returns None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.get_mapped_category_id', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.get_mapped_category_id" class="source">
    <pre><code>def get_mapped_category_id(self, ebay_category_id):
    """
        Determines if the user provided a category mapping, and if so
        returns an integer, which is the Woo Commerce category id that
        is mapped to the `ebay_category_id` (or the Uncategorized category
        id if a mapping can not be found)
        In the case that the user has not provided a category mapping,
        this method returns None
    """
    if self.category_mapping is not None:
        return self.__search_map(ebay_category_id, 'ebay_ids')
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.try_command">
    <p>def <span class="ident">try_command</span>(</p><p>self, command, data)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper for running methods.</p>
<p>Verifies that we support the method, raising a NameError if not
and then runs the method specified in the <code>command</code> argument in
a try, except statement</p>
<p><code>command</code> is a string that is inside <code>__available_commands</code></p>
<p><code>data</code> is dependent on the type of command that is being ran.
In most instances, it is an integer containing the ebay ItemID.</p>
<p>With the <code>delete_all_products</code> command, it is either a range or
a list containing the post ids for existing products</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.try_command', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.try_command" class="source">
    <pre><code>def try_command(self, command, data):
    """
        Wrapper for running methods.
        Verifies that we support the method, raising a NameError if not
        and then runs the method specified in the `command` argument in
        a try, except statement
        `command` is a string that is inside `__available_commands`
        `data` is dependent on the type of command that is being ran.
        In most instances, it is an integer containing the ebay ItemID.
        With the `delete_all_products` command, it is either a range or
        a list containing the post ids for existing products
    """
    __available_commands = [
        'create_product',
        'delete_product',
        'upload_images',
        'delete_all_products',
    ]
    err_msg = "Command %s is unrecognized. Supported commands are: %s" % (
        command, ', '.join(__available_commands))
    if command not in __available_commands:
        self.log.exception(err_msg)
        raise NameError(err_msg)
    try:
        if command == 'create_product':
            return self.create_product(data)
        elif command == 'delete_product':
            return self.delete_product(data)
        elif command == 'upload_images':
            return self.upload_product_images(data)
        elif command == 'delete_all_products':
            return self.delete_all_products_in_range(data)
        else:
            self.log.exception(err_msg)
            raise NameError(err_msg)
    # The several kinds of timeout exceptions that are normally returned by the API
    except (timeout, ReadTimeoutError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout):
        self.log.warning('The Previous request Timed Out. Waiting 5s before retrying')
        time.sleep(5)
        self.try_command(command, data)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.upload_image_to_woocommerce">
    <p>def <span class="ident">upload_image_to_woocommerce</span>(</p><p>self, image, post_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Uploads the provided <code>image</code> to wordpress, and returns the response</p>
<p><code>image</code> is a dictionary containing the following keys:</p>
<p><code>name</code> - This is the destination file name, including extension</p>
<p><code>type</code> - This is the MIMETYPE of the image, usually derived from the extension</p>
<p><code>data</code> - This is a bytes-like object representing the entire image. We get this
from dowloading an image directly from Ebay's servers and temporarily storing it
in memory</p>
<p><code>post_id</code> is the post in which to attach the image to. This is returned in the
response from <code>self.create_product()</code></p>
<p>Returns either a string containing the URL the image can be found at, or False
if the image fails to be uploaded</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.upload_image_to_woocommerce', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.upload_image_to_woocommerce" class="source">
    <pre><code>def upload_image_to_woocommerce(self, image, post_id):
    """
        Uploads the provided `image` to wordpress, and returns the response
        `image` is a dictionary containing the following keys:
        `name` - This is the destination file name, including extension
        `type` - This is the MIMETYPE of the image, usually derived from the extension
        `data` - This is a bytes-like object representing the entire image. We get this
        from dowloading an image directly from Ebay's servers and temporarily storing it
        in memory
        `post_id` is the post in which to attach the image to. This is returned in the
        response from `self.create_product()`
        Returns either a string containing the URL the image can be found at, or False
        if the image fails to be uploaded
    """
    self.log.info("Uploading %s to wordpress" % (image.name))
    endpoint = '/media?post=%d' % (post_id)
    headers = {
        'cache-control': 'no-cache',
        'content-disposition': 'attachment; filename=%s' % (image.name),
        'content-type': '%s' % (image.mime_type)
    }
    # Don't upload a duplicate image if it was uploaded in the past
    if self.__does_image_exist_on_woocommerce(image.slug):
        self.log.warning(
            "Image %s already exists on wordpress. Not uploading again" % (image.name)
        )
        return None, None
    # Upload the image
    response = self.wp_api.post(endpoint, image.data, headers=headers)
    try:
        image_id = response.json().get('id')
        url = response.json().get('guid', dict).get('raw')
        self.log.debug("Uploaded %s to %s" % (image.name, url))
        return image_id, url
    except AttributeError:
        self.log.error('Could not upload %s' % image.name)
        return None, None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.woo.WooCommerceShim.upload_product_images">
    <p>def <span class="ident">upload_product_images</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>With the provided <code>item_id</code>, the database
is searched for the post id (set during
<code>create_product</code>)</p>
<p>When the post_id is found, it will be used
to download the images for that product
from ebay, and then upload the images</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.woo.WooCommerceShim.upload_product_images', this);">Show source &equiv;</a></p>
  <div id="source-shim.woo.WooCommerceShim.upload_product_images" class="source">
    <pre><code>def upload_product_images(self, item_id):
    """
        With the provided `item_id`, the database
        is searched for the post id (set during
        `create_product`)
        When the post_id is found, it will be used
        to download the images for that product
        from ebay, and then upload the images
    """
    post_id = self.db_woo_get_post_id(item_id)
    gallery = []
    if post_id is not None:
        for image in self.download_product_images_from_ebay(item_id):
            image_id, url = self.upload_image_to_woocommerce(image, post_id)
            if image_id and url:
                self.db_metadata_uploaded(image_id, item_id)
                gallery.append({'id': image_id})
        # Add the images to the gallery
        self.api.put('products/%d' % (post_id), {'images': gallery}).json()
    else:
        self.log.warning('The product %d has not yet been uploaded' % (item_id))
    return self
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="shim.woo.WooCommerceShim.api" class="name">var <span class="ident">api</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="shim.woo.WooCommerceShim.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="shim.woo.WooCommerceShim.wp_api" class="name">var <span class="ident">wp_api</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
