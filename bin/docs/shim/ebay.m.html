<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>shim.ebay API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#shim.ebay.EbayShim">EbayShim</a></span>
        
          
  <ul>
    <li class="mono"><a href="#shim.ebay.EbayShim.__init__">__init__</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_ebay_get_got_item_ids">db_ebay_get_got_item_ids</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_ebay_get_request_counter">db_ebay_get_request_counter</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_ebay_got_seller_list_date">db_ebay_got_seller_list_date</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_ebay_increment_request_counter">db_ebay_increment_request_counter</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_ebay_store_got_item_ids">db_ebay_store_got_item_ids</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_ebay_zero_request_counter">db_ebay_zero_request_counter</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_get_active_item_ids">db_get_active_item_ids</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_get_all_item_metadata">db_get_all_item_metadata</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_get_all_items">db_get_all_items</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_get_all_product_metadata">db_get_all_product_metadata</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_get_inactive_uploaded_item_ids">db_get_inactive_uploaded_item_ids</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_get_metadata_post_id_from_value">db_get_metadata_post_id_from_value</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_get_product_data">db_get_product_data</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_get_product_image_urls">db_get_product_image_urls</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_metadata_uploaded">db_metadata_uploaded</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_product_uploaded">db_product_uploaded</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_store_item_from_ebay">db_store_item_from_ebay</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_store_item_metadata_from_ebay">db_store_item_metadata_from_ebay</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.db_woo_get_post_id">db_woo_get_post_id</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.get_item_metadata">get_item_metadata</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.get_seller_list">get_seller_list</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.set_date_range">set_date_range</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.set_range_filter">set_range_filter</a></li>
    <li class="mono"><a href="#shim.ebay.EbayShim.try_command">try_command</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">shim.ebay</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay" class="source">
    <pre><code>#!/usr/bin/env python3
# Part of Ebay-WooCommerce-Shim
# Copyright 2020 David Todd <dtodd@oceantech.com>
# License: Properitary

# Standard Library modules
import os
import sys
import time
import logging
import datetime

from requests import exceptions

# Local modules
from .db import Database
from .util import LOG_HANDLER

# External modules
from ebaysdk.trading import Connection as Trading
from ebaysdk.exception import ConnectionError

class EbayShim(Database):
    """
        Contains various methods for querying the ebay API
        that will get items that are currently active,
        categories, descriptions, etc
    """

    def __init__(self, *args, **kwargs):
        """
            Contains the initial values that this object will
            have when it is created.
        """

        # Initalize the database and logging
        super(EbayShim, self).__init__(*args, **kwargs)

        # Setup logging
        self.log = logging.getLogger(__name__)
        self.log.setLevel(os.environ.get('log_level', 'INFO'))
        self.log.addHandler(LOG_HANDLER)

        # Setup Internals
        # Contains the range of listings to search (defined at `set_date_range`)
        self.date_range = dict()
        # Contains the filters that are applied to
        # seller events searching (defined at `set_range_filter`)
        self.seller_filter_dict = dict()
        # Contains all item ids that are currently active (defined at `get_item_ids`)
        self.got_item_ids = self.db_ebay_get_got_item_ids()

        # Used to determine how many times a paginated request
        # needs to be repeated to get the full data set
        self.pagination_total_items = 0
        self.pagination_total_pages = 0
        self.pagination_received_items = 0

        self.rate_limit = 1000

        # Setup connection to SDK
        self.ebay = self.__get_api_connection()

    def __get_api_connection(self):
        """
            Creates a new connection to the ebay API (via the SDK)

            All parameters are set via environment variables (see creds.example)
        """
        self.log.info('Opening new API connection to %s' % (os.environ.get('ebay_domain', False)))
        return Trading(
            domain=os.environ.get('ebay_domain', False),
            # compatibility=int(os.environ.get('ebay_api_version', 648)),
            appid=os.environ.get('ebay_appid', False),
            certid=os.environ.get('ebay_certid', False),
            devid=os.environ.get('ebay_devid', False),
            token=os.environ.get('ebay_token', False),
            config_file=None,
            debug=False
        )

    def __check_date_type(self, the_date=None):
        """
            Determines if the provided date is either a
            datetime object, a string, or NoneType.

            In the case that it's a datetime object, it
            gets returned. In the case it's a string,
            we attempt to convert it to a datetime object.

            In the case that either conversion fails, or
            `the_date` is None, today's datetime object
            is returned.
        """
        if the_date != None:
            if type(the_date) == type(datetime.datetime.today()):
                self.log.debug('Provided date is a datetime object, passing it through')
                return the_date
            elif type(the_date) == type(''):
                warning = 'Provided date %s is a string, attempting conversion' % (the_date)
                self.log.warning(warning)
                try:
                    return datetime.datetime.strptime(the_date, '%Y-%m-%d')
                except ValueError:
                    self.log.warning('Unable to convert, defaulting to today')
                    return datetime.datetime.today()
        self.log.warning('No Date provided, defaulting to today')
        return datetime.datetime.today()

    def set_date_range(self, start_date=None, days=0, stop_date=None, range_type='Start'):
        """
            Creates a dictionary at `self.date_range` containing a from, to, and type

            `start_date` is optional, and when not defined defaults to today. Expected
            to be either a datetime object, or a date string.

            `days` is optional, and when not defined defaults to the same date as the
            `start_date`. When it is defined, and `stop_date` is not defined, it will
            set the range from that. Negative numbers are supported, and when used,
            will reverse the start and stop dates

            `stop_date` is optional, and when not defined defaults to today + `days`.
            Expected to be either a datetime object, or a date string

            `range_type` is the key that will be searched for. Case Sensitive.
            Supported values are:

            `Start` (default) will search for listings that were started within the
            date range. `Mod` will search for listings that have been modified within the
            date range. `End` will search for listings that are ending within the date range.
        """

        start_date = self.__check_date_type(start_date)

        if stop_date != None:
            stop_date = self.__check_date_type(stop_date)
        else:
            # If the stop date was not defined, set the range
            # based on `days`, which defaults to the same day
            self.log.warning('No Stop Date provided, defaulting to Start Date + %d' % (days))
            stop_date = start_date + datetime.timedelta(days)

        # Convert dates into ISO 8601 (required by the API)
        # Start date is at the absolute beginning of the day
        start_date = start_date.strftime('%Y-%m-%dT00:00:00.000Z')
        # Stop date is at the absolute end of the day
        stop_date = stop_date.strftime('%Y-%m-%dT23:59:59.999Z')

        # If the Stop date is in the past, reverse order
        if stop_date < start_date:
            self.log.info('Stop Date is before Start Date, swapping places')
            stop_date, start_date = start_date, stop_date

        self.date_range = {
            'from': start_date,
            'to': stop_date,
            'type': range_type
        }

        return self

    def set_range_filter(self):
        """
            If `self.seller_filter_dict` already contains a date
            range filter, we need to remove those first,
            and then add the type to the front of the
            keywords (eg StartTimeFrom, StartTimeTo, etc)

            The filter will then be applied from `self.date_range`
        """

        filters = [
            'StartTimeFrom', 'StartTimeTo',
            'ModTimeFrom', 'ModTimeTo',
            'EndTimeFrom', 'EndTimeTo',
        ]

        # If there is already a date range filter on the seller list an
        # exception will be thrown. We can only search one type at a time
        for the_filter in filters:
            try:
                del self.seller_filter_dict[the_filter]
                self.log.debug('Filter: %s was already in the seller list, deleted' % (the_filter))
            except KeyError:
                continue

        self.seller_filter_dict[self.date_range['type'] + 'TimeFrom'] = self.date_range['from']
        self.seller_filter_dict[self.date_range['type'] + 'TimeTo'] = self.date_range['to']

        return self

    def __update_pagination(self, entries=100):
        """
            Adds the pagination requirements to the seller_list dictionary
            (used in requests such as `GetSellerEvents` and `GetSellerList`)

            `entries` is the maximum number of items to return per page.
            The maximum value allowed by the API is 200, default is 25

            https://developer.ebay.com/Devzone/XML/docs/Reference/eBay/GetSellerList.html#Request.Pagination.EntriesPerPage
        """
        if entries > 200:
            self.log.warning('Too many entries requested per page. Maximum is 200 items. Defaulting to 100')
            entries = 100

        if not self.seller_filter_dict.get('Pagination', False):
            self.log.info('Pagination value not set in seller_filter, setting defaults')
            self.seller_filter_dict['Pagination'] = {
                'EntriesPerPage': entries,
                'PageNumber': 1,
            }
        else:
            if self.pagination_total_pages > self.seller_filter_dict['Pagination']['PageNumber']:

                pages_left = (self.pagination_total_pages -
                              self.seller_filter_dict['Pagination']['PageNumber'])
                self.log.info('%d Pages left' % (pages_left))

                if self.pagination_total_items > self.pagination_received_items:

                    items_left = self.pagination_total_items - self.pagination_received_items
                    self.log.info('%d Items left to get' % (items_left))

                    self.seller_filter_dict['Pagination']['PageNumber'] += 1
                else:
                    self.pagination_received_items = 0
                    self.pagination_total_items = 0
            else:
                self.pagination_total_pages = 0

        return self

    def get_item_metadata(self):
        """
            Iterates over all of the active items (`self.got_item_ids`)
            and makes an API request to get the ItemSpecifics (details
            such as the specs of the device, etc). These requests are
            then stored in the item_metadata table.

            If `self.got_item_ids` does not contain at least one item,
            it will be populated with all items that are marked as active
        """

        if not self.got_item_ids:
            self.got_item_ids = self.db_get_active_item_ids()

        if self.got_item_ids:
            for item_id in self.got_item_ids:
                # Remove the current item so that we can store the state
                self.got_item_ids.remove(item_id)

                if self.db_ebay_get_request_counter() >= self.rate_limit:
                    self.log.error('Rate limit reached! Storing the remaining ids for next run')
                    self.db_ebay_store_got_item_ids(self.got_item_ids)
                    break

                # Get the item, with specifc details (specs)
                # Arguments are defined here:
                # https://developer.ebay.com/Devzone/XML/docs/Reference/eBay/GetItem.html#Request.IncludeItemSpecifics
                result = self.ebay.execute(
                    'GetItem',
                    {
                        'IncludeItemSpecifics': True,
                        'ItemID': item_id,
                    }
                ).dict()['Item']

                self.db_ebay_increment_request_counter()
                self.db_store_item_metadata_from_ebay(result)

        if self.got_item_ids:
            self.db_ebay_store_got_item_ids([])

        return self

    def get_seller_list(self):
        """
            Gets multiple items from the same seller based on the date range
        """
        # Default the DetailLevel if it isn't already set
        # 'ItemReturnDescription' gives us the HTML of the
        # description, among other useful information
        if not self.seller_filter_dict.get('DetailLevel', False):
            self.seller_filter_dict['DetailLevel'] = 'ItemReturnDescription'

        # Call `get_seller_list` sequentially to move to the next page
        self.__update_pagination()

        if self.db_ebay_get_request_counter() >= self.rate_limit:
            self.log.error('Rate limit reached! Not getting more items!')
            # Introduce a fake value to the pagination to
            # trick `try_command` to break out of the loop
            self.pagination_received_items = self.pagination_total_items + 1
            return None

        # Run the API request
        result = self.ebay.execute('GetSellerList', self.seller_filter_dict).dict()

        # Record that we sent a request to the ebay API
        self.db_ebay_increment_request_counter()

        # Determine where we are for pagination
        self.pagination_total_items = int(result['PaginationResult']['TotalNumberOfEntries'])
        self.pagination_total_pages = int(result['PaginationResult']['TotalNumberOfPages'])
        self.pagination_received_items += int(result['ReturnedItemCountActual'])

        msg = 'Got %d items out of %d total from the provided date range filter'
        self.log.info(msg % (self.pagination_received_items, self.pagination_total_items))

        item_list = result.get('ItemArray', None)
        if item_list is not None:
            items_active, items_inactive = 0, 0

            # Ensure that the response is a list containing one or more dictionaries
            try:
                for key in item_list['Item']:
                    _ = key['ItemID']
            except TypeError:
                # Only one item was returned
                item_list = [ item_list['Item'] ]
            else:
                item_list = item_list['Item']

            for item in item_list:
                # Store the items in the database for use in syncing to wordpress
                self.db_store_item_from_ebay(item)

                if item['SellingStatus']['ListingStatus'] == 'Active':
                    items_active += 1
                    # Store the metadata for active items only
                    self.db_store_item_metadata_from_ebay(item)
                    # Store active item ids so that we can fetch ItemSpecifics
                    self.got_item_ids.append(item['ItemID'])
                else:
                    items_inactive += 1
                    self.log.debug(
                        'Item %s is not active, not getting its metadata' % (item.get('ItemID'))
                    )

            msg = '%d Items Active and %d Items inactive'
            self.log.info(msg % (items_active, items_inactive))
        else:
            self.log.error('Got no items from the search. Try adjusting the date range')

        return self

    def __print_response(self, full=False):
        if self.ebay.warnings():
            for warning in self.ebay.warnings().split(','):
                self.log.warning(warning)

            print("Warnings" + self.ebay.warnings())

        if self.ebay.response.content and full:
            print("Call Success: %s in length" % (self.ebay.response.content))

        self.log.info("Response Code: %s" % (self.ebay.response_code()))

        if full:
            self.log.debug(self.ebay.response.content)
            self.log.debug(self.ebay.response.json())
            self.log.debug("Response Reply: %s" % (self.ebay.response.reply))
        else:
            response = "%s" % (self.ebay.response.dict())
            reply = "%s" % (self.ebay.response.reply)
            self.log.debug("Response Dictionary: %s..." % (response[:100]))
            self.log.debug("Response Reply: %s..." % (reply[:100]))

        return self

    def try_command(self, command):
        """
            Wrapper for running methods.

            Verifies that we support the method, raising a NameError if not
            and then runs the method specified in the `command` argument in
            a try, except statement

            `command` is a string that is inside `__available_commands`
        """
        __available_commands = [
            'get_seller_list',
            'get_item_metadata',
        ]

        err_msg = "Command %s is unrecognized. Supported commands are: %s" % (
            command, ', '.join(__available_commands))

        if command not in __available_commands:
            self.log.error(err_msg)
            raise NameError(err_msg)

        try:
            if command == 'get_seller_list':
                if self.db_ebay_got_seller_list_date():
                    # We need to run this at least once to populate
                    # `self.pagination_total_items` and `self.pagination_received_items`
                    self.get_seller_list().__print_response()

                    # If there are still items to get, get them
                    while self.pagination_received_items < self.pagination_total_items:
                        self.get_seller_list().__print_response()

                    return self
                else:
                    self.log.warning("Get Seller List already ran today. Skipping")

            elif command == 'get_item_metadata':
                self.get_item_metadata()

            else:
                self.log.error(err_msg)
                raise NameError(err_msg)

        except ConnectionError as e:
            self.log.exception(e)
            self.log.exception(e.response.dict())

        except exceptions.ReadTimeout:
            self.log.warning('The Previous request Timed Out. Waiting 5s before retrying')
            time.sleep(5)
            self.try_command(command)

        except NameError:
            pass

        return self
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="shim.ebay.EbayShim" class="name">class <span class="ident">EbayShim</span></p>
      
  
    <div class="desc"><p>Contains various methods for querying the ebay API
that will get items that are currently active,
categories, descriptions, etc</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim" class="source">
    <pre><code>class EbayShim(Database):
    """
        Contains various methods for querying the ebay API
        that will get items that are currently active,
        categories, descriptions, etc
    """

    def __init__(self, *args, **kwargs):
        """
            Contains the initial values that this object will
            have when it is created.
        """

        # Initalize the database and logging
        super(EbayShim, self).__init__(*args, **kwargs)

        # Setup logging
        self.log = logging.getLogger(__name__)
        self.log.setLevel(os.environ.get('log_level', 'INFO'))
        self.log.addHandler(LOG_HANDLER)

        # Setup Internals
        # Contains the range of listings to search (defined at `set_date_range`)
        self.date_range = dict()
        # Contains the filters that are applied to
        # seller events searching (defined at `set_range_filter`)
        self.seller_filter_dict = dict()
        # Contains all item ids that are currently active (defined at `get_item_ids`)
        self.got_item_ids = self.db_ebay_get_got_item_ids()

        # Used to determine how many times a paginated request
        # needs to be repeated to get the full data set
        self.pagination_total_items = 0
        self.pagination_total_pages = 0
        self.pagination_received_items = 0

        self.rate_limit = 1000

        # Setup connection to SDK
        self.ebay = self.__get_api_connection()

    def __get_api_connection(self):
        """
            Creates a new connection to the ebay API (via the SDK)

            All parameters are set via environment variables (see creds.example)
        """
        self.log.info('Opening new API connection to %s' % (os.environ.get('ebay_domain', False)))
        return Trading(
            domain=os.environ.get('ebay_domain', False),
            # compatibility=int(os.environ.get('ebay_api_version', 648)),
            appid=os.environ.get('ebay_appid', False),
            certid=os.environ.get('ebay_certid', False),
            devid=os.environ.get('ebay_devid', False),
            token=os.environ.get('ebay_token', False),
            config_file=None,
            debug=False
        )

    def __check_date_type(self, the_date=None):
        """
            Determines if the provided date is either a
            datetime object, a string, or NoneType.

            In the case that it's a datetime object, it
            gets returned. In the case it's a string,
            we attempt to convert it to a datetime object.

            In the case that either conversion fails, or
            `the_date` is None, today's datetime object
            is returned.
        """
        if the_date != None:
            if type(the_date) == type(datetime.datetime.today()):
                self.log.debug('Provided date is a datetime object, passing it through')
                return the_date
            elif type(the_date) == type(''):
                warning = 'Provided date %s is a string, attempting conversion' % (the_date)
                self.log.warning(warning)
                try:
                    return datetime.datetime.strptime(the_date, '%Y-%m-%d')
                except ValueError:
                    self.log.warning('Unable to convert, defaulting to today')
                    return datetime.datetime.today()
        self.log.warning('No Date provided, defaulting to today')
        return datetime.datetime.today()

    def set_date_range(self, start_date=None, days=0, stop_date=None, range_type='Start'):
        """
            Creates a dictionary at `self.date_range` containing a from, to, and type

            `start_date` is optional, and when not defined defaults to today. Expected
            to be either a datetime object, or a date string.

            `days` is optional, and when not defined defaults to the same date as the
            `start_date`. When it is defined, and `stop_date` is not defined, it will
            set the range from that. Negative numbers are supported, and when used,
            will reverse the start and stop dates

            `stop_date` is optional, and when not defined defaults to today + `days`.
            Expected to be either a datetime object, or a date string

            `range_type` is the key that will be searched for. Case Sensitive.
            Supported values are:

            `Start` (default) will search for listings that were started within the
            date range. `Mod` will search for listings that have been modified within the
            date range. `End` will search for listings that are ending within the date range.
        """

        start_date = self.__check_date_type(start_date)

        if stop_date != None:
            stop_date = self.__check_date_type(stop_date)
        else:
            # If the stop date was not defined, set the range
            # based on `days`, which defaults to the same day
            self.log.warning('No Stop Date provided, defaulting to Start Date + %d' % (days))
            stop_date = start_date + datetime.timedelta(days)

        # Convert dates into ISO 8601 (required by the API)
        # Start date is at the absolute beginning of the day
        start_date = start_date.strftime('%Y-%m-%dT00:00:00.000Z')
        # Stop date is at the absolute end of the day
        stop_date = stop_date.strftime('%Y-%m-%dT23:59:59.999Z')

        # If the Stop date is in the past, reverse order
        if stop_date < start_date:
            self.log.info('Stop Date is before Start Date, swapping places')
            stop_date, start_date = start_date, stop_date

        self.date_range = {
            'from': start_date,
            'to': stop_date,
            'type': range_type
        }

        return self

    def set_range_filter(self):
        """
            If `self.seller_filter_dict` already contains a date
            range filter, we need to remove those first,
            and then add the type to the front of the
            keywords (eg StartTimeFrom, StartTimeTo, etc)

            The filter will then be applied from `self.date_range`
        """

        filters = [
            'StartTimeFrom', 'StartTimeTo',
            'ModTimeFrom', 'ModTimeTo',
            'EndTimeFrom', 'EndTimeTo',
        ]

        # If there is already a date range filter on the seller list an
        # exception will be thrown. We can only search one type at a time
        for the_filter in filters:
            try:
                del self.seller_filter_dict[the_filter]
                self.log.debug('Filter: %s was already in the seller list, deleted' % (the_filter))
            except KeyError:
                continue

        self.seller_filter_dict[self.date_range['type'] + 'TimeFrom'] = self.date_range['from']
        self.seller_filter_dict[self.date_range['type'] + 'TimeTo'] = self.date_range['to']

        return self

    def __update_pagination(self, entries=100):
        """
            Adds the pagination requirements to the seller_list dictionary
            (used in requests such as `GetSellerEvents` and `GetSellerList`)

            `entries` is the maximum number of items to return per page.
            The maximum value allowed by the API is 200, default is 25

            https://developer.ebay.com/Devzone/XML/docs/Reference/eBay/GetSellerList.html#Request.Pagination.EntriesPerPage
        """
        if entries > 200:
            self.log.warning('Too many entries requested per page. Maximum is 200 items. Defaulting to 100')
            entries = 100

        if not self.seller_filter_dict.get('Pagination', False):
            self.log.info('Pagination value not set in seller_filter, setting defaults')
            self.seller_filter_dict['Pagination'] = {
                'EntriesPerPage': entries,
                'PageNumber': 1,
            }
        else:
            if self.pagination_total_pages > self.seller_filter_dict['Pagination']['PageNumber']:

                pages_left = (self.pagination_total_pages -
                              self.seller_filter_dict['Pagination']['PageNumber'])
                self.log.info('%d Pages left' % (pages_left))

                if self.pagination_total_items > self.pagination_received_items:

                    items_left = self.pagination_total_items - self.pagination_received_items
                    self.log.info('%d Items left to get' % (items_left))

                    self.seller_filter_dict['Pagination']['PageNumber'] += 1
                else:
                    self.pagination_received_items = 0
                    self.pagination_total_items = 0
            else:
                self.pagination_total_pages = 0

        return self

    def get_item_metadata(self):
        """
            Iterates over all of the active items (`self.got_item_ids`)
            and makes an API request to get the ItemSpecifics (details
            such as the specs of the device, etc). These requests are
            then stored in the item_metadata table.

            If `self.got_item_ids` does not contain at least one item,
            it will be populated with all items that are marked as active
        """

        if not self.got_item_ids:
            self.got_item_ids = self.db_get_active_item_ids()

        if self.got_item_ids:
            for item_id in self.got_item_ids:
                # Remove the current item so that we can store the state
                self.got_item_ids.remove(item_id)

                if self.db_ebay_get_request_counter() >= self.rate_limit:
                    self.log.error('Rate limit reached! Storing the remaining ids for next run')
                    self.db_ebay_store_got_item_ids(self.got_item_ids)
                    break

                # Get the item, with specifc details (specs)
                # Arguments are defined here:
                # https://developer.ebay.com/Devzone/XML/docs/Reference/eBay/GetItem.html#Request.IncludeItemSpecifics
                result = self.ebay.execute(
                    'GetItem',
                    {
                        'IncludeItemSpecifics': True,
                        'ItemID': item_id,
                    }
                ).dict()['Item']

                self.db_ebay_increment_request_counter()
                self.db_store_item_metadata_from_ebay(result)

        if self.got_item_ids:
            self.db_ebay_store_got_item_ids([])

        return self

    def get_seller_list(self):
        """
            Gets multiple items from the same seller based on the date range
        """
        # Default the DetailLevel if it isn't already set
        # 'ItemReturnDescription' gives us the HTML of the
        # description, among other useful information
        if not self.seller_filter_dict.get('DetailLevel', False):
            self.seller_filter_dict['DetailLevel'] = 'ItemReturnDescription'

        # Call `get_seller_list` sequentially to move to the next page
        self.__update_pagination()

        if self.db_ebay_get_request_counter() >= self.rate_limit:
            self.log.error('Rate limit reached! Not getting more items!')
            # Introduce a fake value to the pagination to
            # trick `try_command` to break out of the loop
            self.pagination_received_items = self.pagination_total_items + 1
            return None

        # Run the API request
        result = self.ebay.execute('GetSellerList', self.seller_filter_dict).dict()

        # Record that we sent a request to the ebay API
        self.db_ebay_increment_request_counter()

        # Determine where we are for pagination
        self.pagination_total_items = int(result['PaginationResult']['TotalNumberOfEntries'])
        self.pagination_total_pages = int(result['PaginationResult']['TotalNumberOfPages'])
        self.pagination_received_items += int(result['ReturnedItemCountActual'])

        msg = 'Got %d items out of %d total from the provided date range filter'
        self.log.info(msg % (self.pagination_received_items, self.pagination_total_items))

        item_list = result.get('ItemArray', None)
        if item_list is not None:
            items_active, items_inactive = 0, 0

            # Ensure that the response is a list containing one or more dictionaries
            try:
                for key in item_list['Item']:
                    _ = key['ItemID']
            except TypeError:
                # Only one item was returned
                item_list = [ item_list['Item'] ]
            else:
                item_list = item_list['Item']

            for item in item_list:
                # Store the items in the database for use in syncing to wordpress
                self.db_store_item_from_ebay(item)

                if item['SellingStatus']['ListingStatus'] == 'Active':
                    items_active += 1
                    # Store the metadata for active items only
                    self.db_store_item_metadata_from_ebay(item)
                    # Store active item ids so that we can fetch ItemSpecifics
                    self.got_item_ids.append(item['ItemID'])
                else:
                    items_inactive += 1
                    self.log.debug(
                        'Item %s is not active, not getting its metadata' % (item.get('ItemID'))
                    )

            msg = '%d Items Active and %d Items inactive'
            self.log.info(msg % (items_active, items_inactive))
        else:
            self.log.error('Got no items from the search. Try adjusting the date range')

        return self

    def __print_response(self, full=False):
        if self.ebay.warnings():
            for warning in self.ebay.warnings().split(','):
                self.log.warning(warning)

            print("Warnings" + self.ebay.warnings())

        if self.ebay.response.content and full:
            print("Call Success: %s in length" % (self.ebay.response.content))

        self.log.info("Response Code: %s" % (self.ebay.response_code()))

        if full:
            self.log.debug(self.ebay.response.content)
            self.log.debug(self.ebay.response.json())
            self.log.debug("Response Reply: %s" % (self.ebay.response.reply))
        else:
            response = "%s" % (self.ebay.response.dict())
            reply = "%s" % (self.ebay.response.reply)
            self.log.debug("Response Dictionary: %s..." % (response[:100]))
            self.log.debug("Response Reply: %s..." % (reply[:100]))

        return self

    def try_command(self, command):
        """
            Wrapper for running methods.

            Verifies that we support the method, raising a NameError if not
            and then runs the method specified in the `command` argument in
            a try, except statement

            `command` is a string that is inside `__available_commands`
        """
        __available_commands = [
            'get_seller_list',
            'get_item_metadata',
        ]

        err_msg = "Command %s is unrecognized. Supported commands are: %s" % (
            command, ', '.join(__available_commands))

        if command not in __available_commands:
            self.log.error(err_msg)
            raise NameError(err_msg)

        try:
            if command == 'get_seller_list':
                if self.db_ebay_got_seller_list_date():
                    # We need to run this at least once to populate
                    # `self.pagination_total_items` and `self.pagination_received_items`
                    self.get_seller_list().__print_response()

                    # If there are still items to get, get them
                    while self.pagination_received_items < self.pagination_total_items:
                        self.get_seller_list().__print_response()

                    return self
                else:
                    self.log.warning("Get Seller List already ran today. Skipping")

            elif command == 'get_item_metadata':
                self.get_item_metadata()

            else:
                self.log.error(err_msg)
                raise NameError(err_msg)

        except ConnectionError as e:
            self.log.exception(e)
            self.log.exception(e.response.dict())

        except exceptions.ReadTimeout:
            self.log.warning('The Previous request Timed Out. Waiting 5s before retrying')
            time.sleep(5)
            self.try_command(command)

        except NameError:
            pass

        return self
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#shim.ebay.EbayShim">EbayShim</a></li>
          <li>shim.db.Database</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Contains the initial values that this object will
have when it is created.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.__init__', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.__init__" class="source">
    <pre><code>def __init__(self, *args, **kwargs):
    """
        Contains the initial values that this object will
        have when it is created.
    """
    # Initalize the database and logging
    super(EbayShim, self).__init__(*args, **kwargs)
    # Setup logging
    self.log = logging.getLogger(__name__)
    self.log.setLevel(os.environ.get('log_level', 'INFO'))
    self.log.addHandler(LOG_HANDLER)
    # Setup Internals
    # Contains the range of listings to search (defined at `set_date_range`)
    self.date_range = dict()
    # Contains the filters that are applied to
    # seller events searching (defined at `set_range_filter`)
    self.seller_filter_dict = dict()
    # Contains all item ids that are currently active (defined at `get_item_ids`)
    self.got_item_ids = self.db_ebay_get_got_item_ids()
    # Used to determine how many times a paginated request
    # needs to be repeated to get the full data set
    self.pagination_total_items = 0
    self.pagination_total_pages = 0
    self.pagination_received_items = 0
    self.rate_limit = 1000
    # Setup connection to SDK
    self.ebay = self.__get_api_connection()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_ebay_get_got_item_ids">
    <p>def <span class="ident">db_ebay_get_got_item_ids</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Provides a starting point for the program to
continue from when it pulls the item metadata</p>
<p>In the case that no ids were stored previously,
this will default to all active items</p>
<p>Returns a list of ebay item ids</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_ebay_get_got_item_ids', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_ebay_get_got_item_ids" class="source">
    <pre><code>def db_ebay_get_got_item_ids(self):
    """
        Provides a starting point for the program to
        continue from when it pulls the item metadata
        In the case that no ids were stored previously,
        this will default to all active items
        Returns a list of ebay item ids
    """
    query = "SELECT value FROM ebay_internals WHERE key = 'got_item_ids'"
    self.__execute(query)
    ids = json.loads(self.__fetchone('value', '[]'))
    if not ids:
        self.log.warning('No continue point, getting all active items')
        return self.db_get_active_item_ids()
    return ids
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_ebay_get_request_counter">
    <p>def <span class="ident">db_ebay_get_request_counter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns an integer that is the total amount of requests today</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_ebay_get_request_counter', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_ebay_get_request_counter" class="source">
    <pre><code>def db_ebay_get_request_counter(self):
    """
        Returns an integer that is the total amount of requests today
    """
    query = "SELECT value FROM ebay_internals where key = 'requests_today'"
    self.__execute(query)
    return int(self.__fetchone('value', 0))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_ebay_got_seller_list_date">
    <p>def <span class="ident">db_ebay_got_seller_list_date</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Provides a method for preventing the <code>get_seller_list</code> command
from being ran multiple times a day</p>
<p>Returns True when there is either no date, or the date was in
the past. Returns False when there is a date that is today or
in the future</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_ebay_got_seller_list_date', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_ebay_got_seller_list_date" class="source">
    <pre><code>def db_ebay_got_seller_list_date(self):
    """
        Provides a method for preventing the `get_seller_list` command
        from being ran multiple times a day
        Returns True when there is either no date, or the date was in
        the past. Returns False when there is a date that is today or
        in the future
    """
    query = "SELECT value FROM ebay_internals WHERE key = 'got_seller_list_date'"
    self.__execute(query)
    last_date = self.__fetchone('value', 'no')
    if last_date != 'no' and isodate.parse_date(last_date) >= datetime.date.today():
        msg = 'We already ran get_seller_list today (or in the future). Wait until tomorrow'
        self.log.warning(msg)
        return False
    if last_date == 'no' or isodate.parse_date(last_date) < datetime.date.today():
        query = "UPDATE ebay_internals SET value = :isodate WHERE key = 'got_seller_list_date'"
        today = isodate.date_isoformat(datetime.date.today())
        self.__execute(query, {'isodate': today})
        self.db_ebay_zero_request_counter()
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_ebay_increment_request_counter">
    <p>def <span class="ident">db_ebay_increment_request_counter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>For every request made to the ebay API
(Currently only when getting metadata),
we add one to the request counter</p>
<p>Returns None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_ebay_increment_request_counter', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_ebay_increment_request_counter" class="source">
    <pre><code>def db_ebay_increment_request_counter(self):
    """
        For every request made to the ebay API
        (Currently only when getting metadata),
        we add one to the request counter
        Returns None
    """
    requests = self.db_ebay_get_request_counter()
    query = "UPDATE ebay_internals SET value = :requests WHERE key = 'requests_today'"
    self.__execute(query, {'requests': requests + 1,})
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_ebay_store_got_item_ids">
    <p>def <span class="ident">db_ebay_store_got_item_ids</span>(</p><p>self, item_ids)</p>
    </div>
    

    
  
    <div class="desc"><p>Used to save the current state of the program
whenever we hit a rate limit</p>
<p>Returns None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_ebay_store_got_item_ids', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_ebay_store_got_item_ids" class="source">
    <pre><code>def db_ebay_store_got_item_ids(self, item_ids):
    """
        Used to save the current state of the program
        whenever we hit a rate limit
        Returns None
    """
    query = "UPDATE ebay_internals SET value = :items WHERE key = 'got_item_ids'"
    self.__execute(query, {'items': json.dumps(item_ids),})
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_ebay_zero_request_counter">
    <p>def <span class="ident">db_ebay_zero_request_counter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Resets the request counter to 0</p>
<p>The request counter is used to ensure that
we don't make so many API requests to ebay
that we hit the rate limit (5000 requests/day)</p>
<p>Returns None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_ebay_zero_request_counter', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_ebay_zero_request_counter" class="source">
    <pre><code>def db_ebay_zero_request_counter(self):
    """
        Resets the request counter to 0
        The request counter is used to ensure that
        we don't make so many API requests to ebay
        that we hit the rate limit (5000 requests/day)
        Returns None
    """
    query = "UPDATE ebay_internals SET value = 0 WHERE key = 'requests_today'"
    self.__execute(query)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_get_active_item_ids">
    <p>def <span class="ident">db_get_active_item_ids</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Searches the local database for all items that
are marked as active</p>
<p>Returns a list containing all the item ids</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_get_active_item_ids', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_get_active_item_ids" class="source">
    <pre><code>def db_get_active_item_ids(self):
    """
        Searches the local database for all items that
        are marked as active
        Returns a list containing all the item ids
    """
    self.log.debug('Getting all active IDs')
    query = "SELECT item_id FROM items WHERE active = 'Active' AND post_id IS NULL;"
    self.__execute(query)
    item_ids = self.__cursor.fetchall()
    return [ i['item_id'] for i in item_ids if i['item_id'] ]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_get_all_item_metadata">
    <p>def <span class="ident">db_get_all_item_metadata</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_get_all_item_metadata', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_get_all_item_metadata" class="source">
    <pre><code>def db_get_all_item_metadata(self):
    self.__execute('SELECT * from item_metadata')
    return self.__fetchall()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_get_all_items">
    <p>def <span class="ident">db_get_all_items</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_get_all_items', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_get_all_items" class="source">
    <pre><code>def db_get_all_items(self):
    self.__execute('SELECT * FROM items;')
    return self.__fetchall()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_get_all_product_metadata">
    <p>def <span class="ident">db_get_all_product_metadata</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>For the provided <code>item_id</code>, the local database
is searched for all occurrences of metadata that
match, and extracts that if any are found</p>
<p>Returns a list of dictionaries, where each dictionary
is one key-value combination for the data stored
or an empty list if nothing is found</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_get_all_product_metadata', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_get_all_product_metadata" class="source">
    <pre><code>def db_get_all_product_metadata(self, item_id):
    """
        For the provided `item_id`, the local database
        is searched for all occurrences of metadata that
        match, and extracts that if any are found
        Returns a list of dictionaries, where each dictionary
        is one key-value combination for the data stored
        or an empty list if nothing is found
    """
    query = "SELECT key, value FROM item_metadata WHERE item_id = :item_id;"
    values = {
        'item_id': str(item_id),
    }
    self.__execute(query, values)
    return self.__fetchall()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_get_inactive_uploaded_item_ids">
    <p>def <span class="ident">db_get_inactive_uploaded_item_ids</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_get_inactive_uploaded_item_ids', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_get_inactive_uploaded_item_ids" class="source">
    <pre><code>def db_get_inactive_uploaded_item_ids(self):
    query = """
        SELECT item_id FROM items
        WHERE
            post_id is not NULL AND
            active != 'Active' OR
            end_date <= date('now')
    """
    self.__execute(query)
    item_ids = self.__fetchall()
    return [ i['item_id'] for i in item_ids if i['item_id'] ]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_get_metadata_post_id_from_value">
    <p>def <span class="ident">db_get_metadata_post_id_from_value</span>(</p><p>self, value)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_get_metadata_post_id_from_value', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_get_metadata_post_id_from_value" class="source">
    <pre><code>def db_get_metadata_post_id_from_value(self, value):
    query = """
        SELECT * FROM item_metadata
        WHERE value = :value
        LIMIT 1
    """
    self.__execute(query, {'value': value})
    return self.__fetchone('post_id')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_get_product_data">
    <p>def <span class="ident">db_get_product_data</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>For the provided <code>item_id</code>, the local database
is searched for the matching row and extracts it
if one is found, and it has quantity and is marked
as active</p>
<p>Returns a dictionary containing the product data
or an empty dictionary</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_get_product_data', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_get_product_data" class="source">
    <pre><code>def db_get_product_data(self, item_id):
    """
        For the provided `item_id`, the local database
        is searched for the matching row and extracts it
        if one is found, and it has quantity and is marked
        as active
        Returns a dictionary containing the product data
        or an empty dictionary
    """
    query = """
        SELECT *
        FROM items
        WHERE
            available_quantity > 0 AND
            item_id = :item_id
        LIMIT 1
    """
    values = {
        'item_id': str(item_id),
    }
    self.__execute(query, values)
    try:
        return dict(self.__cursor.fetchone())
    except TypeError:
        return {}
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_get_product_image_urls">
    <p>def <span class="ident">db_get_product_image_urls</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Gets all product image URLs that are
associated with a particular <code>item_id</code></p>
<p>Returns a list containing one or more
URLs to download images from, sorted
alphabetically</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_get_product_image_urls', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_get_product_image_urls" class="source">
    <pre><code>def db_get_product_image_urls(self, item_id):
    """
        Gets all product image URLs that are
        associated with a particular `item_id`
        Returns a list containing one or more
        URLs to download images from, sorted
        alphabetically
    """
    query = """
        SELECT value, post_id FROM item_metadata
        WHERE
            item_id = :item_id AND
            key = 'picture_url'
        ORDER BY value;
    """
    values = {
        'item_id': str(item_id),
    }
    self.__execute(query, values)
    return self.__fetchall()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_metadata_uploaded">
    <p>def <span class="ident">db_metadata_uploaded</span>(</p><p>self, post_id, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Shortcut to mark product metadata (such as images and attributes)
as uploaded by storing the post it is a part of</p>
<p>Returns <code>self</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_metadata_uploaded', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_metadata_uploaded" class="source">
    <pre><code>def db_metadata_uploaded(self, post_id, item_id):
    """
        Shortcut to mark product metadata (such as images and attributes)
        as uploaded by storing the post it is a part of
        Returns `self`
    """
    return self.__mark_data_as_uploaded('metadata', post_id, item_id)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_product_uploaded">
    <p>def <span class="ident">db_product_uploaded</span>(</p><p>self, post_id, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Shortcut to mark products as uploaded by storing the post it is a part of</p>
<p>Returns <code>self</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_product_uploaded', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_product_uploaded" class="source">
    <pre><code>def db_product_uploaded(self, post_id, item_id):
    """
        Shortcut to mark products as uploaded by storing the post it is a part of
        Returns `self`
    """
    return self.__mark_data_as_uploaded('product', post_id, item_id)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_store_item_from_ebay">
    <p>def <span class="ident">db_store_item_from_ebay</span>(</p><p>self, item)</p>
    </div>
    

    
  
    <div class="desc"><p>Store the provided <code>item</code>, which is a dictionary,
into the local database. This gets all information
that is normally returned from GetSellerList.</p>
<p>For ItemSpecifics, we will have to make a seperate
API call to GetItem with the DetailLevel set to
ReturnAll (something that is not allowed on bulk
queries such as GetSellerList and GetSellerEvents)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_store_item_from_ebay', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_store_item_from_ebay" class="source">
    <pre><code>def db_store_item_from_ebay(self, item):
    """
        Store the provided `item`, which is a dictionary,
        into the local database. This gets all information
        that is normally returned from GetSellerList.
        For ItemSpecifics, we will have to make a seperate
        API call to GetItem with the DetailLevel set to
        ReturnAll (something that is not allowed on bulk
        queries such as GetSellerList and GetSellerEvents)
    """
    # INSERT OR REPLACE so that we can always ensure that the
    # saved information is up to date (or at least recent)
    query = """
        INSERT OR REPLACE INTO items (
            item_id, active, available_quantity,
            title, sku, start_date, end_date,
            category_id, category_name, condition_name,
            condition_description
        ) VALUES (
            :item_id, :active, :available_quantity,
            :title, :sku, :start_date, :end_date,
            :category_id, :category_name, :condition_name,
            :condition_description)
    """
    values = {
        'item_id': int(item['ItemID']),
        'active': item['SellingStatus']['ListingStatus'],
        'available_quantity': int(item['Quantity']) - int(item['SellingStatus']['QuantitySold']),
        'title': item['Title'],
        'sku': item.get('SKU', uuid.uuid4().hex),
        'start_date': self.__get_datetime_obj(item['ListingDetails']['StartTime']),
        'end_date': self.__get_datetime_obj(item['ListingDetails']['EndTime']),
        'category_id': int(item['PrimaryCategory']['CategoryID']),
        'category_name': item['PrimaryCategory']['CategoryName'],
        'condition_name': '',
        'condition_description': '',
    }
    # These fields have a chance to not exist, so we set default empty values
    # and then try to add them after the dictionary is created
    if item.get('ConditionDisplayName', False):
        values['condition_name'] = item['ConditionDisplayName']
    if item.get('ConditionDescription', False):
        values['condition_description'] = item['ConditionDescription']
    self.__execute(query, values)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_store_item_metadata_from_ebay">
    <p>def <span class="ident">db_store_item_metadata_from_ebay</span>(</p><p>self, item)</p>
    </div>
    

    
  
    <div class="desc"><p>Store the provided <code>item</code>, which is a dictionary,
into the local database. We're specifically after
metadata such as picture urls, and item specifics.</p>
<p>When this is called from GetSellerList, the PictureDetails
are what are normally provided. When this is called from
GetItem, ItemSpecifics are what are normally provided</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_store_item_metadata_from_ebay', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_store_item_metadata_from_ebay" class="source">
    <pre><code>def db_store_item_metadata_from_ebay(self, item):
    """
        Store the provided `item`, which is a dictionary,
        into the local database. We're specifically after
        metadata such as picture urls, and item specifics.
        When this is called from GetSellerList, the PictureDetails
        are what are normally provided. When this is called from
        GetItem, ItemSpecifics are what are normally provided
    """
    # PictureDetails exists on GetSellerList and GetItem, so this should always get hit
    if item.get('PictureDetails', False):
        self.log.debug('Found Picture Details for %d' % (int(item['ItemID'])))
        if type(item['PictureDetails']['PictureURL']) is list:
            for picture in item['PictureDetails']['PictureURL']:
                self.__store_key_value(item['ItemID'], 'picture_url', picture)
        # Case for only one picture being on a listing
        elif type(item['PictureDetails']['PictureURL']) is str:
            self.__store_key_value(
                item['ItemID'], 'picture_url',
                item['PictureDetails']['PictureURL'])
        else:
            err_msg = 'Unexpected type %s from PictureDetails. Expecting either list or str'
            self.log.error(err_msg % (type(item['PictureDetails']['PictureURL'])))
    # ItemSpecifics only exists on GetItem when `IncludeItemSpecifics` is True
    if item.get('ItemSpecifics', False):
        self.log.debug('Found Specific Details for %d' % (int(item['ItemID'])))
        if type(item['ItemSpecifics']['NameValueList']) is list:
            for detail in item['ItemSpecifics']['NameValueList']:
                if type(detail['Value']) is list:
                    detail['Value'] = ', '.join(detail['Value'])
                self.__store_key_value(item['ItemID'], detail['Name'], detail['Value'])
        # Case for only one ItemSpecifc field
        elif type(item['ItemSpecifics']['NameValueList']) is dict:
            values = item['ItemSpecifics']['NameValueList']
            if type(values['Value']) is list:
                detail['Value'] = ', '.join(detail['Value'])
            self.__store_key_value(item['ItemID'], values['Name'], values['Value'])
        else:
            err_msg = 'Unexpected type %s from ItemSpecifics. Expecting either list or str'
            self.log.error(err_msg % (type(item['ItemSpecifics']['NameValueList'])))
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.db_woo_get_post_id">
    <p>def <span class="ident">db_woo_get_post_id</span>(</p><p>self, item_id)</p>
    </div>
    

    
  
    <div class="desc"><p>Searches the database for <code>item_id</code>, and will
return the value of the <code>post_id</code> column.</p>
<p>If the product has not been uploaded to Woo Commerce,
this will return None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.db_woo_get_post_id', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.db_woo_get_post_id" class="source">
    <pre><code>def db_woo_get_post_id(self, item_id):
    """
        Searches the database for `item_id`, and will
        return the value of the `post_id` column.
        If the product has not been uploaded to Woo Commerce,
        this will return None
    """
    query = "SELECT post_id FROM items WHERE item_id = :item_id"
    self.__execute(query, {'item_id': item_id})
    return self.__fetchone('post_id')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.get_item_metadata">
    <p>def <span class="ident">get_item_metadata</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Iterates over all of the active items (<code>self.got_item_ids</code>)
and makes an API request to get the ItemSpecifics (details
such as the specs of the device, etc). These requests are
then stored in the item_metadata table.</p>
<p>If <code>self.got_item_ids</code> does not contain at least one item,
it will be populated with all items that are marked as active</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.get_item_metadata', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.get_item_metadata" class="source">
    <pre><code>def get_item_metadata(self):
    """
        Iterates over all of the active items (`self.got_item_ids`)
        and makes an API request to get the ItemSpecifics (details
        such as the specs of the device, etc). These requests are
        then stored in the item_metadata table.
        If `self.got_item_ids` does not contain at least one item,
        it will be populated with all items that are marked as active
    """
    if not self.got_item_ids:
        self.got_item_ids = self.db_get_active_item_ids()
    if self.got_item_ids:
        for item_id in self.got_item_ids:
            # Remove the current item so that we can store the state
            self.got_item_ids.remove(item_id)
            if self.db_ebay_get_request_counter() >= self.rate_limit:
                self.log.error('Rate limit reached! Storing the remaining ids for next run')
                self.db_ebay_store_got_item_ids(self.got_item_ids)
                break
            # Get the item, with specifc details (specs)
            # Arguments are defined here:
            # https://developer.ebay.com/Devzone/XML/docs/Reference/eBay/GetItem.html#Request.IncludeItemSpecifics
            result = self.ebay.execute(
                'GetItem',
                {
                    'IncludeItemSpecifics': True,
                    'ItemID': item_id,
                }
            ).dict()['Item']
            self.db_ebay_increment_request_counter()
            self.db_store_item_metadata_from_ebay(result)
    if self.got_item_ids:
        self.db_ebay_store_got_item_ids([])
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.get_seller_list">
    <p>def <span class="ident">get_seller_list</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Gets multiple items from the same seller based on the date range</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.get_seller_list', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.get_seller_list" class="source">
    <pre><code>def get_seller_list(self):
    """
        Gets multiple items from the same seller based on the date range
    """
    # Default the DetailLevel if it isn't already set
    # 'ItemReturnDescription' gives us the HTML of the
    # description, among other useful information
    if not self.seller_filter_dict.get('DetailLevel', False):
        self.seller_filter_dict['DetailLevel'] = 'ItemReturnDescription'
    # Call `get_seller_list` sequentially to move to the next page
    self.__update_pagination()
    if self.db_ebay_get_request_counter() >= self.rate_limit:
        self.log.error('Rate limit reached! Not getting more items!')
        # Introduce a fake value to the pagination to
        # trick `try_command` to break out of the loop
        self.pagination_received_items = self.pagination_total_items + 1
        return None
    # Run the API request
    result = self.ebay.execute('GetSellerList', self.seller_filter_dict).dict()
    # Record that we sent a request to the ebay API
    self.db_ebay_increment_request_counter()
    # Determine where we are for pagination
    self.pagination_total_items = int(result['PaginationResult']['TotalNumberOfEntries'])
    self.pagination_total_pages = int(result['PaginationResult']['TotalNumberOfPages'])
    self.pagination_received_items += int(result['ReturnedItemCountActual'])
    msg = 'Got %d items out of %d total from the provided date range filter'
    self.log.info(msg % (self.pagination_received_items, self.pagination_total_items))
    item_list = result.get('ItemArray', None)
    if item_list is not None:
        items_active, items_inactive = 0, 0
        # Ensure that the response is a list containing one or more dictionaries
        try:
            for key in item_list['Item']:
                _ = key['ItemID']
        except TypeError:
            # Only one item was returned
            item_list = [ item_list['Item'] ]
        else:
            item_list = item_list['Item']
        for item in item_list:
            # Store the items in the database for use in syncing to wordpress
            self.db_store_item_from_ebay(item)
            if item['SellingStatus']['ListingStatus'] == 'Active':
                items_active += 1
                # Store the metadata for active items only
                self.db_store_item_metadata_from_ebay(item)
                # Store active item ids so that we can fetch ItemSpecifics
                self.got_item_ids.append(item['ItemID'])
            else:
                items_inactive += 1
                self.log.debug(
                    'Item %s is not active, not getting its metadata' % (item.get('ItemID'))
                )
        msg = '%d Items Active and %d Items inactive'
        self.log.info(msg % (items_active, items_inactive))
    else:
        self.log.error('Got no items from the search. Try adjusting the date range')
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.set_date_range">
    <p>def <span class="ident">set_date_range</span>(</p><p>self, start_date=None, days=0, stop_date=None, range_type=&#39;Start&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a dictionary at <code>self.date_range</code> containing a from, to, and type</p>
<p><code>start_date</code> is optional, and when not defined defaults to today. Expected
to be either a datetime object, or a date string.</p>
<p><code>days</code> is optional, and when not defined defaults to the same date as the
<code>start_date</code>. When it is defined, and <code>stop_date</code> is not defined, it will
set the range from that. Negative numbers are supported, and when used,
will reverse the start and stop dates</p>
<p><code>stop_date</code> is optional, and when not defined defaults to today + <code>days</code>.
Expected to be either a datetime object, or a date string</p>
<p><code>range_type</code> is the key that will be searched for. Case Sensitive.
Supported values are:</p>
<p><code>Start</code> (default) will search for listings that were started within the
date range. <code>Mod</code> will search for listings that have been modified within the
date range. <code>End</code> will search for listings that are ending within the date range.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.set_date_range', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.set_date_range" class="source">
    <pre><code>def set_date_range(self, start_date=None, days=0, stop_date=None, range_type='Start'):
    """
        Creates a dictionary at `self.date_range` containing a from, to, and type
        `start_date` is optional, and when not defined defaults to today. Expected
        to be either a datetime object, or a date string.
        `days` is optional, and when not defined defaults to the same date as the
        `start_date`. When it is defined, and `stop_date` is not defined, it will
        set the range from that. Negative numbers are supported, and when used,
        will reverse the start and stop dates
        `stop_date` is optional, and when not defined defaults to today + `days`.
        Expected to be either a datetime object, or a date string
        `range_type` is the key that will be searched for. Case Sensitive.
        Supported values are:
        `Start` (default) will search for listings that were started within the
        date range. `Mod` will search for listings that have been modified within the
        date range. `End` will search for listings that are ending within the date range.
    """
    start_date = self.__check_date_type(start_date)
    if stop_date != None:
        stop_date = self.__check_date_type(stop_date)
    else:
        # If the stop date was not defined, set the range
        # based on `days`, which defaults to the same day
        self.log.warning('No Stop Date provided, defaulting to Start Date + %d' % (days))
        stop_date = start_date + datetime.timedelta(days)
    # Convert dates into ISO 8601 (required by the API)
    # Start date is at the absolute beginning of the day
    start_date = start_date.strftime('%Y-%m-%dT00:00:00.000Z')
    # Stop date is at the absolute end of the day
    stop_date = stop_date.strftime('%Y-%m-%dT23:59:59.999Z')
    # If the Stop date is in the past, reverse order
    if stop_date < start_date:
        self.log.info('Stop Date is before Start Date, swapping places')
        stop_date, start_date = start_date, stop_date
    self.date_range = {
        'from': start_date,
        'to': stop_date,
        'type': range_type
    }
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.set_range_filter">
    <p>def <span class="ident">set_range_filter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>If <code>self.seller_filter_dict</code> already contains a date
range filter, we need to remove those first,
and then add the type to the front of the
keywords (eg StartTimeFrom, StartTimeTo, etc)</p>
<p>The filter will then be applied from <code>self.date_range</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.set_range_filter', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.set_range_filter" class="source">
    <pre><code>def set_range_filter(self):
    """
        If `self.seller_filter_dict` already contains a date
        range filter, we need to remove those first,
        and then add the type to the front of the
        keywords (eg StartTimeFrom, StartTimeTo, etc)
        The filter will then be applied from `self.date_range`
    """
    filters = [
        'StartTimeFrom', 'StartTimeTo',
        'ModTimeFrom', 'ModTimeTo',
        'EndTimeFrom', 'EndTimeTo',
    ]
    # If there is already a date range filter on the seller list an
    # exception will be thrown. We can only search one type at a time
    for the_filter in filters:
        try:
            del self.seller_filter_dict[the_filter]
            self.log.debug('Filter: %s was already in the seller list, deleted' % (the_filter))
        except KeyError:
            continue
    self.seller_filter_dict[self.date_range['type'] + 'TimeFrom'] = self.date_range['from']
    self.seller_filter_dict[self.date_range['type'] + 'TimeTo'] = self.date_range['to']
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="shim.ebay.EbayShim.try_command">
    <p>def <span class="ident">try_command</span>(</p><p>self, command)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper for running methods.</p>
<p>Verifies that we support the method, raising a NameError if not
and then runs the method specified in the <code>command</code> argument in
a try, except statement</p>
<p><code>command</code> is a string that is inside <code>__available_commands</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-shim.ebay.EbayShim.try_command', this);">Show source &equiv;</a></p>
  <div id="source-shim.ebay.EbayShim.try_command" class="source">
    <pre><code>def try_command(self, command):
    """
        Wrapper for running methods.
        Verifies that we support the method, raising a NameError if not
        and then runs the method specified in the `command` argument in
        a try, except statement
        `command` is a string that is inside `__available_commands`
    """
    __available_commands = [
        'get_seller_list',
        'get_item_metadata',
    ]
    err_msg = "Command %s is unrecognized. Supported commands are: %s" % (
        command, ', '.join(__available_commands))
    if command not in __available_commands:
        self.log.error(err_msg)
        raise NameError(err_msg)
    try:
        if command == 'get_seller_list':
            if self.db_ebay_got_seller_list_date():
                # We need to run this at least once to populate
                # `self.pagination_total_items` and `self.pagination_received_items`
                self.get_seller_list().__print_response()
                # If there are still items to get, get them
                while self.pagination_received_items < self.pagination_total_items:
                    self.get_seller_list().__print_response()
                return self
            else:
                self.log.warning("Get Seller List already ran today. Skipping")
        elif command == 'get_item_metadata':
            self.get_item_metadata()
        else:
            self.log.error(err_msg)
            raise NameError(err_msg)
    except ConnectionError as e:
        self.log.exception(e)
        self.log.exception(e.response.dict())
    except exceptions.ReadTimeout:
        self.log.warning('The Previous request Timed Out. Waiting 5s before retrying')
        time.sleep(5)
        self.try_command(command)
    except NameError:
        pass
    return self
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="shim.ebay.EbayShim.date_range" class="name">var <span class="ident">date_range</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="shim.ebay.EbayShim.ebay" class="name">var <span class="ident">ebay</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="shim.ebay.EbayShim.got_item_ids" class="name">var <span class="ident">got_item_ids</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="shim.ebay.EbayShim.log" class="name">var <span class="ident">log</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="shim.ebay.EbayShim.pagination_received_items" class="name">var <span class="ident">pagination_received_items</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="shim.ebay.EbayShim.pagination_total_items" class="name">var <span class="ident">pagination_total_items</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="shim.ebay.EbayShim.pagination_total_pages" class="name">var <span class="ident">pagination_total_pages</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="shim.ebay.EbayShim.rate_limit" class="name">var <span class="ident">rate_limit</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="shim.ebay.EbayShim.seller_filter_dict" class="name">var <span class="ident">seller_filter_dict</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
